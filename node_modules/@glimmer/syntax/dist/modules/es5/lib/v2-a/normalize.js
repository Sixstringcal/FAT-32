function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

import { assert, assign, isPresent } from '@glimmer/util';
import Printer from '../generation/printer';
import { preprocess } from '../parser/tokenizer-event-handlers';
import { SourceSlice } from '../source/slice';
import { SpanList } from '../source/span-list';
import { SymbolTable } from '../symbol-table';
import { generateSyntaxError } from '../syntax-error';
import { isLowerCase, isUpperCase } from '../utils';
import b from '../v1/parser-builders';
import * as ASTv2 from './api';
import { Builder } from './builders';
import { AppendSyntaxContext, AttrValueSyntaxContext, BlockSyntaxContext, ComponentSyntaxContext, ModifierSyntaxContext, SexpSyntaxContext } from './loose-resolution';
export function normalize(source, options) {
  if (options === void 0) {
    options = {};
  }

  var _a;

  var ast = preprocess(source, options);
  var normalizeOptions = assign({
    strictMode: false,
    locals: []
  }, options);
  var top = SymbolTable.top(normalizeOptions.strictMode ? normalizeOptions.locals : [], (_a = // eslint-disable-next-line @typescript-eslint/unbound-method
  options.customizeComponentName) !== null && _a !== void 0 ? _a : function (name) {
    return name;
  });
  var block = new BlockContext(source, normalizeOptions, top);
  var normalizer = new StatementNormalizer(block);
  var astV2 = new TemplateChildren(block.loc(ast.loc), ast.body.map(function (b) {
    return normalizer.normalize(b);
  }), block).assertTemplate(top);
  var locals = top.getUsedTemplateLocals();
  return [astV2, locals];
}
/**
 * A `BlockContext` represents the block that a particular AST node is contained inside of.
 *
 * `BlockContext` is aware of template-wide options (such as strict mode), as well as the bindings
 * that are in-scope within that block.
 *
 * Concretely, it has the `PrecompileOptions` and current `SymbolTable`, and provides
 * facilities for working with those options.
 *
 * `BlockContext` is stateless.
 */

export var BlockContext = /*#__PURE__*/function () {
  function BlockContext(source, options, table) {
    this.source = source;
    this.options = options;
    this.table = table;
    this.builder = new Builder();
  }

  var _proto = BlockContext.prototype;

  _proto.loc = function loc(_loc) {
    return this.source.spanFor(_loc);
  };

  _proto.resolutionFor = function resolutionFor(node, resolution) {
    if (this.strict) {
      return {
        resolution: ASTv2.STRICT_RESOLUTION
      };
    }

    if (this.isFreeVar(node)) {
      var r = resolution(node);

      if (r === null) {
        return {
          resolution: 'error',
          path: printPath(node),
          head: printHead(node)
        };
      }

      return {
        resolution: r
      };
    } else {
      return {
        resolution: ASTv2.STRICT_RESOLUTION
      };
    }
  };

  _proto.isFreeVar = function isFreeVar(callee) {
    if (callee.type === 'PathExpression') {
      if (callee.head.type !== 'VarHead') {
        return false;
      }

      return !this.table.has(callee.head.name);
    } else if (callee.path.type === 'PathExpression') {
      return this.isFreeVar(callee.path);
    } else {
      return false;
    }
  };

  _proto.hasBinding = function hasBinding(name) {
    return this.table.has(name);
  };

  _proto.child = function child(blockParams) {
    return new BlockContext(this.source, this.options, this.table.child(blockParams));
  };

  _proto.customizeComponentName = function customizeComponentName(input) {
    if (this.options.customizeComponentName) {
      return this.options.customizeComponentName(input);
    } else {
      return input;
    }
  };

  _createClass(BlockContext, [{
    key: "strict",
    get: function get() {
      return this.options.strictMode || false;
    }
  }]);

  return BlockContext;
}();
/**
 * An `ExpressionNormalizer` normalizes expressions within a block.
 *
 * `ExpressionNormalizer` is stateless.
 */

var ExpressionNormalizer = /*#__PURE__*/function () {
  function ExpressionNormalizer(block) {
    this.block = block;
  }

  var _proto2 = ExpressionNormalizer.prototype;

  _proto2.normalize = function normalize(expr, resolution) {
    switch (expr.type) {
      case 'NullLiteral':
      case 'BooleanLiteral':
      case 'NumberLiteral':
      case 'StringLiteral':
      case 'UndefinedLiteral':
        return this.block.builder.literal(expr.value, this.block.loc(expr.loc));

      case 'PathExpression':
        return this.path(expr, resolution);

      case 'SubExpression':
        {
          var _resolution = this.block.resolutionFor(expr, SexpSyntaxContext);

          if (_resolution.resolution === 'error') {
            throw generateSyntaxError("You attempted to invoke a path (`" + _resolution.path + "`) but " + _resolution.head + " was not in scope", expr.loc);
          }

          return this.block.builder.sexp(this.callParts(expr, _resolution.resolution), this.block.loc(expr.loc));
        }
    }
  };

  _proto2.path = function path(expr, resolution) {
    var headOffsets = this.block.loc(expr.head.loc);
    var tail = []; // start with the head

    var offset = headOffsets;

    for (var _iterator = _createForOfIteratorHelperLoose(expr.tail), _step; !(_step = _iterator()).done;) {
      var part = _step.value;
      offset = offset.sliceStartChars({
        chars: part.length,
        skipStart: 1
      });
      tail.push(new SourceSlice({
        loc: offset,
        chars: part
      }));
    }

    return this.block.builder.path(this.ref(expr.head, resolution), tail, this.block.loc(expr.loc));
  }
  /**
   * The `callParts` method takes ASTv1.CallParts as well as a syntax context and normalizes
   * it to an ASTv2 CallParts.
   */
  ;

  _proto2.callParts = function callParts(parts, context) {
    var _this = this;

    var path = parts.path,
        params = parts.params,
        hash = parts.hash;
    var callee = this.normalize(path, context);
    var paramList = params.map(function (p) {
      return _this.normalize(p, ASTv2.ARGUMENT_RESOLUTION);
    });
    var paramLoc = SpanList.range(paramList, callee.loc.collapse('end'));
    var namedLoc = this.block.loc(hash.loc);
    var argsLoc = SpanList.range([paramLoc, namedLoc]);
    var positional = this.block.builder.positional(params.map(function (p) {
      return _this.normalize(p, ASTv2.ARGUMENT_RESOLUTION);
    }), paramLoc);
    var named = this.block.builder.named(hash.pairs.map(function (p) {
      return _this.namedArgument(p);
    }), this.block.loc(hash.loc));
    return {
      callee: callee,
      args: this.block.builder.args(positional, named, argsLoc)
    };
  };

  _proto2.namedArgument = function namedArgument(pair) {
    var offsets = this.block.loc(pair.loc);
    var keyOffsets = offsets.sliceStartChars({
      chars: pair.key.length
    });
    return this.block.builder.namedArgument(new SourceSlice({
      chars: pair.key,
      loc: keyOffsets
    }), this.normalize(pair.value, ASTv2.ARGUMENT_RESOLUTION));
  }
  /**
   * The `ref` method normalizes an `ASTv1.PathHead` into an `ASTv2.VariableReference`.
   * This method is extremely important, because it is responsible for normalizing free
   * variables into an an ASTv2.PathHead *with appropriate context*.
   *
   * The syntax context is originally determined by the syntactic position that this `PathHead`
   * came from, and is ultimately attached to the `ASTv2.VariableReference` here. In ASTv2,
   * the `VariableReference` node bears full responsibility for loose mode rules that control
   * the behavior of free variables.
   */
  ;

  _proto2.ref = function ref(head, resolution) {
    var block = this.block;
    var builder = block.builder,
        table = block.table;
    var offsets = block.loc(head.loc);

    switch (head.type) {
      case 'ThisHead':
        return builder.self(offsets);

      case 'AtHead':
        {
          var symbol = table.allocateNamed(head.name);
          return builder.at(head.name, symbol, offsets);
        }

      case 'VarHead':
        {
          if (block.hasBinding(head.name)) {
            var _table$get = table.get(head.name),
                _symbol = _table$get[0],
                isRoot = _table$get[1];

            return block.builder.localVar(head.name, _symbol, isRoot, offsets);
          } else {
            var context = block.strict ? ASTv2.STRICT_RESOLUTION : resolution;

            var _symbol2 = block.table.allocateFree(head.name, context);

            return block.builder.freeVar({
              name: head.name,
              context: context,
              symbol: _symbol2,
              loc: offsets
            });
          }
        }
    }
  };

  return ExpressionNormalizer;
}();
/**
 * `TemplateNormalizer` normalizes top-level ASTv1 statements to ASTv2.
 */


var StatementNormalizer = /*#__PURE__*/function () {
  function StatementNormalizer(block) {
    this.block = block;
  }

  var _proto3 = StatementNormalizer.prototype;

  _proto3.normalize = function normalize(node) {
    switch (node.type) {
      case 'PartialStatement':
        throw new Error("Handlebars partial syntax ({{> ...}}) is not allowed in Glimmer");

      case 'BlockStatement':
        return this.BlockStatement(node);

      case 'ElementNode':
        return new ElementNormalizer(this.block).ElementNode(node);

      case 'MustacheStatement':
        return this.MustacheStatement(node);
      // These are the same in ASTv2

      case 'MustacheCommentStatement':
        return this.MustacheCommentStatement(node);

      case 'CommentStatement':
        {
          var loc = this.block.loc(node.loc);
          return new ASTv2.HtmlComment({
            loc: loc,
            text: loc.slice({
              skipStart: 4,
              skipEnd: 3
            }).toSlice(node.value)
          });
        }

      case 'TextNode':
        return new ASTv2.HtmlText({
          loc: this.block.loc(node.loc),
          chars: node.chars
        });
    }
  };

  _proto3.MustacheCommentStatement = function MustacheCommentStatement(node) {
    var loc = this.block.loc(node.loc);
    var textLoc;

    if (loc.asString().slice(0, 5) === '{{!--') {
      textLoc = loc.slice({
        skipStart: 5,
        skipEnd: 4
      });
    } else {
      textLoc = loc.slice({
        skipStart: 3,
        skipEnd: 2
      });
    }

    return new ASTv2.GlimmerComment({
      loc: loc,
      text: textLoc.toSlice(node.value)
    });
  }
  /**
   * Normalizes an ASTv1.MustacheStatement to an ASTv2.AppendStatement
   */
  ;

  _proto3.MustacheStatement = function MustacheStatement(mustache) {
    var escaped = mustache.escaped;
    var loc = this.block.loc(mustache.loc); // Normalize the call parts in AppendSyntaxContext

    var callParts = this.expr.callParts({
      path: mustache.path,
      params: mustache.params,
      hash: mustache.hash
    }, AppendSyntaxContext(mustache));
    var value = callParts.args.isEmpty() ? callParts.callee : this.block.builder.sexp(callParts, loc);
    return this.block.builder.append({
      table: this.block.table,
      trusting: !escaped,
      value: value
    }, loc);
  }
  /**
   * Normalizes a ASTv1.BlockStatement to an ASTv2.BlockStatement
   */
  ;

  _proto3.BlockStatement = function BlockStatement(block) {
    var program = block.program,
        inverse = block.inverse;
    var loc = this.block.loc(block.loc);
    var resolution = this.block.resolutionFor(block, BlockSyntaxContext);

    if (resolution.resolution === 'error') {
      throw generateSyntaxError("You attempted to invoke a path (`{{#" + resolution.path + "}}`) but " + resolution.head + " was not in scope", loc);
    }

    var callParts = this.expr.callParts(block, resolution.resolution);
    return this.block.builder.blockStatement(assign({
      symbols: this.block.table,
      program: this.Block(program),
      inverse: inverse ? this.Block(inverse) : null
    }, callParts), loc);
  };

  _proto3.Block = function Block(_ref) {
    var body = _ref.body,
        loc = _ref.loc,
        blockParams = _ref.blockParams;
    var child = this.block.child(blockParams);
    var normalizer = new StatementNormalizer(child);
    return new BlockChildren(this.block.loc(loc), body.map(function (b) {
      return normalizer.normalize(b);
    }), this.block).assertBlock(child.table);
  };

  _createClass(StatementNormalizer, [{
    key: "expr",
    get: function get() {
      return new ExpressionNormalizer(this.block);
    }
  }]);

  return StatementNormalizer;
}();

var ElementNormalizer = /*#__PURE__*/function () {
  function ElementNormalizer(ctx) {
    this.ctx = ctx;
  }
  /**
   * Normalizes an ASTv1.ElementNode to:
   *
   * - ASTv2.NamedBlock if the tag name begins with `:`
   * - ASTv2.Component if the tag name matches the component heuristics
   * - ASTv2.SimpleElement if the tag name doesn't match the component heuristics
   *
   * A tag name represents a component if:
   *
   * - it begins with `@`
   * - it is exactly `this` or begins with `this.`
   * - the part before the first `.` is a reference to an in-scope variable binding
   * - it begins with an uppercase character
   */


  var _proto4 = ElementNormalizer.prototype;

  _proto4.ElementNode = function ElementNode(element) {
    var _this2 = this;

    var tag = element.tag,
        selfClosing = element.selfClosing,
        comments = element.comments;
    var loc = this.ctx.loc(element.loc);

    var _tag$split = tag.split('.'),
        tagHead = _tag$split[0],
        rest = _tag$split.slice(1); // the head, attributes and modifiers are in the current scope


    var path = this.classifyTag(tagHead, rest, element.loc);
    var attrs = element.attributes.filter(function (a) {
      return a.name[0] !== '@';
    }).map(function (a) {
      return _this2.attr(a);
    });
    var args = element.attributes.filter(function (a) {
      return a.name[0] === '@';
    }).map(function (a) {
      return _this2.arg(a);
    });
    var modifiers = element.modifiers.map(function (m) {
      return _this2.modifier(m);
    }); // the element's block params are in scope for the children

    var child = this.ctx.child(element.blockParams);
    var normalizer = new StatementNormalizer(child);
    var childNodes = element.children.map(function (s) {
      return normalizer.normalize(s);
    });
    var el = this.ctx.builder.element({
      selfClosing: selfClosing,
      attrs: attrs,
      componentArgs: args,
      modifiers: modifiers,
      comments: comments.map(function (c) {
        return new StatementNormalizer(_this2.ctx).MustacheCommentStatement(c);
      })
    });
    var children = new ElementChildren(el, loc, childNodes, this.ctx);
    var offsets = this.ctx.loc(element.loc);
    var tagOffsets = offsets.sliceStartChars({
      chars: tag.length,
      skipStart: 1
    });

    if (path === 'ElementHead') {
      if (tag[0] === ':') {
        return children.assertNamedBlock(tagOffsets.slice({
          skipStart: 1
        }).toSlice(tag.slice(1)), child.table);
      } else {
        return children.assertElement(tagOffsets.toSlice(tag), element.blockParams.length > 0);
      }
    }

    if (element.selfClosing) {
      return el.selfClosingComponent(path, loc);
    } else {
      var blocks = children.assertComponent(tag, child.table, element.blockParams.length > 0);
      return el.componentWithNamedBlocks(path, blocks, loc);
    }
  };

  _proto4.modifier = function modifier(m) {
    var resolution = this.ctx.resolutionFor(m, ModifierSyntaxContext);

    if (resolution.resolution === 'error') {
      throw generateSyntaxError("You attempted to invoke a path (`{{#" + resolution.path + "}}`) as a modifier, but " + resolution.head + " was not in scope. Try adding `this` to the beginning of the path", m.loc);
    }

    var callParts = this.expr.callParts(m, resolution.resolution);
    return this.ctx.builder.modifier(callParts, this.ctx.loc(m.loc));
  }
  /**
   * This method handles attribute values that are curlies, as well as curlies nested inside of
   * interpolations:
   *
   * ```hbs
   * <a href={{url}} />
   * <a href="{{url}}.html" />
   * ```
   */
  ;

  _proto4.mustacheAttr = function mustacheAttr(mustache) {
    // Normalize the call parts in AttrValueSyntaxContext
    var sexp = this.ctx.builder.sexp(this.expr.callParts(mustache, AttrValueSyntaxContext(mustache)), this.ctx.loc(mustache.loc)); // If there are no params or hash, just return the function part as its own expression

    if (sexp.args.isEmpty()) {
      return sexp.callee;
    } else {
      return sexp;
    }
  }
  /**
   * attrPart is the narrowed down list of valid attribute values that are also
   * allowed as a concat part (you can't nest concats).
   */
  ;

  _proto4.attrPart = function attrPart(part) {
    switch (part.type) {
      case 'MustacheStatement':
        return {
          expr: this.mustacheAttr(part),
          trusting: !part.escaped
        };

      case 'TextNode':
        return {
          expr: this.ctx.builder.literal(part.chars, this.ctx.loc(part.loc)),
          trusting: true
        };
    }
  };

  _proto4.attrValue = function attrValue(part) {
    var _this3 = this;

    switch (part.type) {
      case 'ConcatStatement':
        {
          var parts = part.parts.map(function (p) {
            return _this3.attrPart(p).expr;
          });
          return {
            expr: this.ctx.builder.interpolate(parts, this.ctx.loc(part.loc)),
            trusting: false
          };
        }

      default:
        return this.attrPart(part);
    }
  };

  _proto4.attr = function attr(m) {
    false && assert(m.name[0] !== '@', 'An attr name must not start with `@`');

    if (m.name === '...attributes') {
      return this.ctx.builder.splatAttr(this.ctx.table.allocateBlock('attrs'), this.ctx.loc(m.loc));
    }

    var offsets = this.ctx.loc(m.loc);
    var nameSlice = offsets.sliceStartChars({
      chars: m.name.length
    }).toSlice(m.name);
    var value = this.attrValue(m.value);
    return this.ctx.builder.attr({
      name: nameSlice,
      value: value.expr,
      trusting: value.trusting
    }, offsets);
  };

  _proto4.maybeDeprecatedCall = function maybeDeprecatedCall(arg, part) {
    if (this.ctx.strict) {
      return null;
    }

    if (part.type !== 'MustacheStatement') {
      return null;
    }

    var path = part.path;

    if (path.type !== 'PathExpression') {
      return null;
    }

    if (path.head.type !== 'VarHead') {
      return null;
    }

    var name = path.head.name;

    if (name === 'has-block' || name === 'has-block-params') {
      return null;
    }

    if (this.ctx.hasBinding(name)) {
      return null;
    }

    if (path.tail.length !== 0) {
      return null;
    }

    if (part.params.length !== 0 || part.hash.pairs.length !== 0) {
      return null;
    }

    var context = ASTv2.LooseModeResolution.attr();
    var callee = this.ctx.builder.freeVar({
      name: name,
      context: context,
      symbol: this.ctx.table.allocateFree(name, context),
      loc: path.loc
    });
    return {
      expr: this.ctx.builder.deprecatedCall(arg, callee, part.loc),
      trusting: false
    };
  };

  _proto4.arg = function arg(_arg) {
    false && assert(_arg.name[0] === '@', 'An arg name must start with `@`');
    var offsets = this.ctx.loc(_arg.loc);
    var nameSlice = offsets.sliceStartChars({
      chars: _arg.name.length
    }).toSlice(_arg.name);
    var value = this.maybeDeprecatedCall(nameSlice, _arg.value) || this.attrValue(_arg.value);
    return this.ctx.builder.arg({
      name: nameSlice,
      value: value.expr,
      trusting: value.trusting
    }, offsets);
  }
  /**
   * This function classifies the head of an ASTv1.Element into an ASTv2.PathHead (if the
   * element is a component) or `'ElementHead'` (if the element is a simple element).
   *
   * Rules:
   *
   * 1. If the variable is an `@arg`, return an `AtHead`
   * 2. If the variable is `this`, return a `ThisHead`
   * 3. If the variable is in the current scope:
   *   a. If the scope is the root scope, then return a Free `LocalVarHead`
   *   b. Else, return a standard `LocalVarHead`
   * 4. If the tag name is a path and the variable is not in the current scope, Syntax Error
   * 5. If the variable is uppercase return a FreeVar(ResolveAsComponentHead)
   * 6. Otherwise, return `'ElementHead'`
   */
  ;

  _proto4.classifyTag = function classifyTag(variable, tail, loc) {
    var uppercase = isUpperCase(variable);
    var inScope = variable[0] === '@' || variable === 'this' || this.ctx.hasBinding(variable);

    if (this.ctx.strict && !inScope) {
      if (uppercase) {
        throw generateSyntaxError("Attempted to invoke a component that was not in scope in a strict mode template, `<" + variable + ">`. If you wanted to create an element with that name, convert it to lowercase - `<" + variable.toLowerCase() + ">`", loc);
      } // In strict mode, values are always elements unless they are in scope


      return 'ElementHead';
    } // Since the parser handed us the HTML element name as a string, we need
    // to convert it into an ASTv1 path so it can be processed using the
    // expression normalizer.


    var isComponent = inScope || uppercase;
    var variableLoc = loc.sliceStartChars({
      skipStart: 1,
      chars: variable.length
    });
    var tailLength = tail.reduce(function (accum, part) {
      return accum + 1 + part.length;
    }, 0);
    var pathEnd = variableLoc.getEnd().move(tailLength);
    var pathLoc = variableLoc.withEnd(pathEnd);

    if (isComponent) {
      var path = b.path({
        head: b.head(variable, variableLoc),
        tail: tail,
        loc: pathLoc
      });
      var resolution = this.ctx.resolutionFor(path, ComponentSyntaxContext);

      if (resolution.resolution === 'error') {
        throw generateSyntaxError("You attempted to invoke a path (`<" + resolution.path + ">`) but " + resolution.head + " was not in scope", loc);
      }

      return new ExpressionNormalizer(this.ctx).normalize(path, resolution.resolution);
    } // If the tag name wasn't a valid component but contained a `.`, it's
    // a syntax error.


    if (tail.length > 0) {
      throw generateSyntaxError("You used " + variable + "." + tail.join('.') + " as a tag name, but " + variable + " is not in scope", loc);
    }

    return 'ElementHead';
  };

  _createClass(ElementNormalizer, [{
    key: "expr",
    get: function get() {
      return new ExpressionNormalizer(this.ctx);
    }
  }]);

  return ElementNormalizer;
}();

var Children = function Children(loc, children, block) {
  this.loc = loc;
  this.children = children;
  this.block = block;
  this.namedBlocks = children.filter(function (c) {
    return c instanceof ASTv2.NamedBlock;
  });
  this.hasSemanticContent = Boolean(children.filter(function (c) {
    if (c instanceof ASTv2.NamedBlock) {
      return false;
    }

    switch (c.type) {
      case 'GlimmerComment':
      case 'HtmlComment':
        return false;

      case 'HtmlText':
        return !/^\s*$/.exec(c.chars);

      default:
        return true;
    }
  }).length);
  this.nonBlockChildren = children.filter(function (c) {
    return !(c instanceof ASTv2.NamedBlock);
  });
};

var TemplateChildren = /*#__PURE__*/function (_Children) {
  _inheritsLoose(TemplateChildren, _Children);

  function TemplateChildren() {
    return _Children.apply(this, arguments) || this;
  }

  var _proto5 = TemplateChildren.prototype;

  _proto5.assertTemplate = function assertTemplate(table) {
    if (isPresent(this.namedBlocks)) {
      throw generateSyntaxError("Unexpected named block at the top-level of a template", this.loc);
    }

    return this.block.builder.template(table, this.nonBlockChildren, this.block.loc(this.loc));
  };

  return TemplateChildren;
}(Children);

var BlockChildren = /*#__PURE__*/function (_Children2) {
  _inheritsLoose(BlockChildren, _Children2);

  function BlockChildren() {
    return _Children2.apply(this, arguments) || this;
  }

  var _proto6 = BlockChildren.prototype;

  _proto6.assertBlock = function assertBlock(table) {
    if (isPresent(this.namedBlocks)) {
      throw generateSyntaxError("Unexpected named block nested in a normal block", this.loc);
    }

    return this.block.builder.block(table, this.nonBlockChildren, this.loc);
  };

  return BlockChildren;
}(Children);

var ElementChildren = /*#__PURE__*/function (_Children3) {
  _inheritsLoose(ElementChildren, _Children3);

  function ElementChildren(el, loc, children, block) {
    var _this4;

    _this4 = _Children3.call(this, loc, children, block) || this;
    _this4.el = el;
    return _this4;
  }

  var _proto7 = ElementChildren.prototype;

  _proto7.assertNamedBlock = function assertNamedBlock(name, table) {
    if (this.el.base.selfClosing) {
      throw generateSyntaxError("<:" + name.chars + "/> is not a valid named block: named blocks cannot be self-closing", this.loc);
    }

    if (isPresent(this.namedBlocks)) {
      throw generateSyntaxError("Unexpected named block inside <:" + name.chars + "> named block: named blocks cannot contain nested named blocks", this.loc);
    }

    if (!isLowerCase(name.chars)) {
      throw generateSyntaxError("<:" + name.chars + "> is not a valid named block, and named blocks must begin with a lowercase letter", this.loc);
    }

    if (this.el.base.attrs.length > 0 || this.el.base.componentArgs.length > 0 || this.el.base.modifiers.length > 0) {
      throw generateSyntaxError("named block <:" + name.chars + "> cannot have attributes, arguments, or modifiers", this.loc);
    }

    var offsets = SpanList.range(this.nonBlockChildren, this.loc);
    return this.block.builder.namedBlock(name, this.block.builder.block(table, this.nonBlockChildren, offsets), this.loc);
  };

  _proto7.assertElement = function assertElement(name, hasBlockParams) {
    if (hasBlockParams) {
      throw generateSyntaxError("Unexpected block params in <" + name + ">: simple elements cannot have block params", this.loc);
    }

    if (isPresent(this.namedBlocks)) {
      var names = this.namedBlocks.map(function (b) {
        return b.name;
      });

      if (names.length === 1) {
        throw generateSyntaxError("Unexpected named block <:foo> inside <" + name.chars + "> HTML element", this.loc);
      } else {
        var printedNames = names.map(function (n) {
          return "<:" + n.chars + ">";
        }).join(', ');
        throw generateSyntaxError("Unexpected named blocks inside <" + name.chars + "> HTML element (" + printedNames + ")", this.loc);
      }
    }

    return this.el.simple(name, this.nonBlockChildren, this.loc);
  };

  _proto7.assertComponent = function assertComponent(name, table, hasBlockParams) {
    if (isPresent(this.namedBlocks) && this.hasSemanticContent) {
      throw generateSyntaxError("Unexpected content inside <" + name + "> component invocation: when using named blocks, the tag cannot contain other content", this.loc);
    }

    if (isPresent(this.namedBlocks)) {
      if (hasBlockParams) {
        throw generateSyntaxError("Unexpected block params list on <" + name + "> component invocation: when passing named blocks, the invocation tag cannot take block params", this.loc);
      }

      var seenNames = new Set();

      for (var _iterator2 = _createForOfIteratorHelperLoose(this.namedBlocks), _step2; !(_step2 = _iterator2()).done;) {
        var block = _step2.value;
        var _name = block.name.chars;

        if (seenNames.has(_name)) {
          throw generateSyntaxError("Component had two named blocks with the same name, `<:" + _name + ">`. Only one block with a given name may be passed", this.loc);
        }

        if (_name === 'inverse' && seenNames.has('else') || _name === 'else' && seenNames.has('inverse')) {
          throw generateSyntaxError("Component has both <:else> and <:inverse> block. <:inverse> is an alias for <:else>", this.loc);
        }

        seenNames.add(_name);
      }

      return this.namedBlocks;
    } else {
      return [this.block.builder.namedBlock(SourceSlice.synthetic('default'), this.block.builder.block(table, this.nonBlockChildren, this.loc), this.loc)];
    }
  };

  return ElementChildren;
}(Children);

function printPath(node) {
  if (node.type !== 'PathExpression' && node.path.type === 'PathExpression') {
    return printPath(node.path);
  } else {
    return new Printer({
      entityEncoding: 'raw'
    }).print(node);
  }
}

function printHead(node) {
  if (node.type === 'PathExpression') {
    switch (node.head.type) {
      case 'AtHead':
      case 'VarHead':
        return node.head.name;

      case 'ThisHead':
        return 'this';
    }
  } else if (node.path.type === 'PathExpression') {
    return printHead(node.path);
  } else {
    return new Printer({
      entityEncoding: 'raw'
    }).print(node);
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvdjItYS9ub3JtYWxpemUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQ0EsU0FBQSxNQUFBLEVBQUEsTUFBQSxFQUFBLFNBQUEsUUFBQSxlQUFBO0FBRUEsT0FBQSxPQUFBLE1BQUEsdUJBQUE7QUFDQSxTQUFBLFVBQUEsUUFBQSxvQ0FBQTtBQUVBLFNBQUEsV0FBQSxRQUFBLGlCQUFBO0FBR0EsU0FBQSxRQUFBLFFBQUEscUJBQUE7QUFDQSxTQUFBLFdBQUEsUUFBQSxpQkFBQTtBQUNBLFNBQUEsbUJBQUEsUUFBQSxpQkFBQTtBQUNBLFNBQUEsV0FBQSxFQUFBLFdBQUEsUUFBQSxVQUFBO0FBRUEsT0FBQSxDQUFBLE1BQUEsdUJBQUE7QUFDQSxPQUFPLEtBQVAsS0FBQSxNQUFBLE9BQUE7QUFDQSxTQUFBLE9BQUEsUUFBQSxZQUFBO0FBQ0EsU0FBQSxtQkFBQSxFQUFBLHNCQUFBLEVBQUEsa0JBQUEsRUFBQSxzQkFBQSxFQUFBLHFCQUFBLEVBQUEsaUJBQUEsUUFBQSxvQkFBQTtBQVVBLE9BQU0sU0FBQSxTQUFBLENBQUEsTUFBQSxFQUVKLE9BRkksRUFFMkI7QUFBQSxNQUEvQixPQUErQjtBQUEvQixJQUFBLE9BQStCLEdBRjNCLEVBRTJCO0FBQUE7Ozs7QUFFL0IsTUFBSSxHQUFHLEdBQUcsVUFBVSxDQUFBLE1BQUEsRUFBcEIsT0FBb0IsQ0FBcEI7QUFFQSxNQUFJLGdCQUFnQixHQUFHLE1BQU0sQ0FDM0I7QUFDRSxJQUFBLFVBQVUsRUFEWixLQUFBO0FBRUUsSUFBQSxNQUFNLEVBQUU7QUFGVixHQUQyQixFQUE3QixPQUE2QixDQUE3QjtBQVFBLE1BQUksR0FBRyxHQUFHLFdBQVcsQ0FBWCxHQUFBLENBQ1IsZ0JBQWdCLENBQWhCLFVBQUEsR0FBOEIsZ0JBQWdCLENBQTlDLE1BQUEsR0FEUSxFQUFBLEVBQ2tELENBQUEsRUFBQSxHQUMxRDtB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RixHOzs7RUF2SUgsUTs7QUEwSUEsU0FBQSxTQUFBLENBQUEsSUFBQSxFQUE4RDtBQUM1RCxNQUFJLElBQUksQ0FBSixJQUFBLEtBQUEsZ0JBQUEsSUFBa0MsSUFBSSxDQUFKLElBQUEsQ0FBQSxJQUFBLEtBQXRDLGdCQUFBLEVBQTJFO0FBQ3pFLFdBQU8sU0FBUyxDQUFDLElBQUksQ0FBckIsSUFBZ0IsQ0FBaEI7QUFERixHQUFBLE1BRU87QUFDTCxXQUFPLElBQUEsT0FBQSxDQUFZO0FBQUUsTUFBQSxjQUFjLEVBQUU7QUFBbEIsS0FBWixFQUFBLEtBQUEsQ0FBUCxJQUFPLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQUEsU0FBQSxDQUFBLElBQUEsRUFBOEQ7QUFDNUQsTUFBSSxJQUFJLENBQUosSUFBQSxLQUFKLGdCQUFBLEVBQW9DO0FBQ2xDLFlBQVEsSUFBSSxDQUFKLElBQUEsQ0FBUixJQUFBO0FBQ0UsV0FBQSxRQUFBO0FBQ0EsV0FBQSxTQUFBO0FBQ0UsZUFBTyxJQUFJLENBQUosSUFBQSxDQUFQLElBQUE7O0FBQ0YsV0FBQSxVQUFBO0FBQ0UsZUFBQSxNQUFBO0FBTEo7QUFERixHQUFBLE1BUU8sSUFBSSxJQUFJLENBQUosSUFBQSxDQUFBLElBQUEsS0FBSixnQkFBQSxFQUF5QztBQUM5QyxXQUFPLFNBQVMsQ0FBQyxJQUFJLENBQXJCLElBQWdCLENBQWhCO0FBREssR0FBQSxNQUVBO0FBQ0wsV0FBTyxJQUFBLE9BQUEsQ0FBWTtBQUFFLE1BQUEsY0FBYyxFQUFFO0FBQWxCLEtBQVosRUFBQSxLQUFBLENBQVAsSUFBTyxDQUFQO0FBQ0Q7QUFDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByZXNlbnRBcnJheSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NpZ24sIGlzUHJlc2VudCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5pbXBvcnQgUHJpbnRlciBmcm9tICcuLi9nZW5lcmF0aW9uL3ByaW50ZXInO1xuaW1wb3J0IHsgUHJlY29tcGlsZU9wdGlvbnMsIHByZXByb2Nlc3MgfSBmcm9tICcuLi9wYXJzZXIvdG9rZW5pemVyLWV2ZW50LWhhbmRsZXJzJztcbmltcG9ydCB7IFNvdXJjZUxvY2F0aW9uIH0gZnJvbSAnLi4vc291cmNlL2xvY2F0aW9uJztcbmltcG9ydCB7IFNvdXJjZVNsaWNlIH0gZnJvbSAnLi4vc291cmNlL3NsaWNlJztcbmltcG9ydCB7IFNvdXJjZSB9IGZyb20gJy4uL3NvdXJjZS9zb3VyY2UnO1xuaW1wb3J0IHsgU291cmNlU3BhbiB9IGZyb20gJy4uL3NvdXJjZS9zcGFuJztcbmltcG9ydCB7IFNwYW5MaXN0IH0gZnJvbSAnLi4vc291cmNlL3NwYW4tbGlzdCc7XG5pbXBvcnQgeyBCbG9ja1N5bWJvbFRhYmxlLCBQcm9ncmFtU3ltYm9sVGFibGUsIFN5bWJvbFRhYmxlIH0gZnJvbSAnLi4vc3ltYm9sLXRhYmxlJztcbmltcG9ydCB7IGdlbmVyYXRlU3ludGF4RXJyb3IgfSBmcm9tICcuLi9zeW50YXgtZXJyb3InO1xuaW1wb3J0IHsgaXNMb3dlckNhc2UsIGlzVXBwZXJDYXNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0ICogYXMgQVNUdjEgZnJvbSAnLi4vdjEvYXBpJztcbmltcG9ydCBiIGZyb20gJy4uL3YxL3BhcnNlci1idWlsZGVycyc7XG5pbXBvcnQgKiBhcyBBU1R2MiBmcm9tICcuL2FwaSc7XG5pbXBvcnQgeyBCdWlsZEVsZW1lbnQsIEJ1aWxkZXIsIENhbGxQYXJ0cyB9IGZyb20gJy4vYnVpbGRlcnMnO1xuaW1wb3J0IHtcbiAgQXBwZW5kU3ludGF4Q29udGV4dCxcbiAgQXR0clZhbHVlU3ludGF4Q29udGV4dCxcbiAgQmxvY2tTeW50YXhDb250ZXh0LFxuICBDb21wb25lbnRTeW50YXhDb250ZXh0LFxuICBNb2RpZmllclN5bnRheENvbnRleHQsXG4gIFJlc29sdXRpb24sXG4gIFNleHBTeW50YXhDb250ZXh0LFxufSBmcm9tICcuL2xvb3NlLXJlc29sdXRpb24nO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKFxuICBzb3VyY2U6IFNvdXJjZSxcbiAgb3B0aW9uczogUHJlY29tcGlsZU9wdGlvbnMgPSB7fVxuKTogW2FzdDogQVNUdjIuVGVtcGxhdGUsIGxvY2Fsczogc3RyaW5nW11dIHtcbiAgbGV0IGFzdCA9IHByZXByb2Nlc3Moc291cmNlLCBvcHRpb25zKTtcblxuICBsZXQgbm9ybWFsaXplT3B0aW9ucyA9IGFzc2lnbihcbiAgICB7XG4gICAgICBzdHJpY3RNb2RlOiBmYWxzZSxcbiAgICAgIGxvY2FsczogW10sXG4gICAgfSxcbiAgICBvcHRpb25zXG4gICk7XG5cbiAgbGV0IHRvcCA9IFN5bWJvbFRhYmxlLnRvcChcbiAgICBub3JtYWxpemVPcHRpb25zLnN0cmljdE1vZGUgPyBub3JtYWxpemVPcHRpb25zLmxvY2FscyA6IFtdLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICBvcHRpb25zLmN1c3RvbWl6ZUNvbXBvbmVudE5hbWUgPz8gKChuYW1lKSA9PiBuYW1lKVxuICApO1xuICBsZXQgYmxvY2sgPSBuZXcgQmxvY2tDb250ZXh0KHNvdXJjZSwgbm9ybWFsaXplT3B0aW9ucywgdG9wKTtcbiAgbGV0IG5vcm1hbGl6ZXIgPSBuZXcgU3RhdGVtZW50Tm9ybWFsaXplcihibG9jayk7XG5cbiAgbGV0IGFzdFYyID0gbmV3IFRlbXBsYXRlQ2hpbGRyZW4oXG4gICAgYmxvY2subG9jKGFzdC5sb2MpLFxuICAgIGFzdC5ib2R5Lm1hcCgoYikgPT4gbm9ybWFsaXplci5ub3JtYWxpemUoYikpLFxuICAgIGJsb2NrXG4gICkuYXNzZXJ0VGVtcGxhdGUodG9wKTtcblxuICBsZXQgbG9jYWxzID0gdG9wLmdldFVzZWRUZW1wbGF0ZUxvY2FscygpO1xuXG4gIHJldHVybiBbYXN0VjIsIGxvY2Fsc107XG59XG5cbi8qKlxuICogQSBgQmxvY2tDb250ZXh0YCByZXByZXNlbnRzIHRoZSBibG9jayB0aGF0IGEgcGFydGljdWxhciBBU1Qgbm9kZSBpcyBjb250YWluZWQgaW5zaWRlIG9mLlxuICpcbiAqIGBCbG9ja0NvbnRleHRgIGlzIGF3YXJlIG9mIHRlbXBsYXRlLXdpZGUgb3B0aW9ucyAoc3VjaCBhcyBzdHJpY3QgbW9kZSksIGFzIHdlbGwgYXMgdGhlIGJpbmRpbmdzXG4gKiB0aGF0IGFyZSBpbi1zY29wZSB3aXRoaW4gdGhhdCBibG9jay5cbiAqXG4gKiBDb25jcmV0ZWx5LCBpdCBoYXMgdGhlIGBQcmVjb21waWxlT3B0aW9uc2AgYW5kIGN1cnJlbnQgYFN5bWJvbFRhYmxlYCwgYW5kIHByb3ZpZGVzXG4gKiBmYWNpbGl0aWVzIGZvciB3b3JraW5nIHdpdGggdGhvc2Ugb3B0aW9ucy5cbiAqXG4gKiBgQmxvY2tDb250ZXh0YCBpcyBzdGF0ZWxlc3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBCbG9ja0NvbnRleHQ8VGFibGUgZXh0ZW5kcyBTeW1ib2xUYWJsZSA9IFN5bWJvbFRhYmxlPiB7XG4gIHJlYWRvbmx5IGJ1aWxkZXI6IEJ1aWxkZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgc291cmNlOiBTb3VyY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBQcmVjb21waWxlT3B0aW9ucyxcbiAgICByZWFkb25seSB0YWJsZTogVGFibGVcbiAgKSB7XG4gICAgdGhpcy5idWlsZGVyID0gbmV3IEJ1aWxkZXIoKTtcbiAgfVxuXG4gIGdldCBzdHJpY3QoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zdHJpY3RNb2RlIHx8IGZhbHNlO1xuICB9XG5cbiAgbG9jKGxvYzogU291cmNlTG9jYXRpb24pOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3BhbkZvcihsb2MpO1xuICB9XG5cbiAgcmVzb2x1dGlvbkZvcjxOIGV4dGVuZHMgQVNUdjEuQ2FsbE5vZGUgfCBBU1R2MS5QYXRoRXhwcmVzc2lvbj4oXG4gICAgbm9kZTogTixcbiAgICByZXNvbHV0aW9uOiBSZXNvbHV0aW9uPE4+XG4gICk6IHsgcmVzb2x1dGlvbjogQVNUdjIuRnJlZVZhclJlc29sdXRpb24gfSB8IHsgcmVzb2x1dGlvbjogJ2Vycm9yJzsgcGF0aDogc3RyaW5nOyBoZWFkOiBzdHJpbmcgfSB7XG4gICAgaWYgKHRoaXMuc3RyaWN0KSB7XG4gICAgICByZXR1cm4geyByZXNvbHV0aW9uOiBBU1R2Mi5TVFJJQ1RfUkVTT0xVVElPTiB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRnJlZVZhcihub2RlKSkge1xuICAgICAgbGV0IHIgPSByZXNvbHV0aW9uKG5vZGUpO1xuXG4gICAgICBpZiAociA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc29sdXRpb246ICdlcnJvcicsXG4gICAgICAgICAgcGF0aDogcHJpbnRQYXRoKG5vZGUpLFxuICAgICAgICAgIGhlYWQ6IHByaW50SGVhZChub2RlKSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgcmVzb2x1dGlvbjogciB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyByZXNvbHV0aW9uOiBBU1R2Mi5TVFJJQ1RfUkVTT0xVVElPTiB9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaXNGcmVlVmFyKGNhbGxlZTogQVNUdjEuQ2FsbE5vZGUgfCBBU1R2MS5QYXRoRXhwcmVzc2lvbik6IGJvb2xlYW4ge1xuICAgIGlmIChjYWxsZWUudHlwZSA9PT0gJ1BhdGhFeHByZXNzaW9uJykge1xuICAgICAgaWYgKGNhbGxlZS5oZWFkLnR5cGUgIT09ICdWYXJIZWFkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhdGhpcy50YWJsZS5oYXMoY2FsbGVlLmhlYWQubmFtZSk7XG4gICAgfSBlbHNlIGlmIChjYWxsZWUucGF0aC50eXBlID09PSAnUGF0aEV4cHJlc3Npb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0ZyZWVWYXIoY2FsbGVlLnBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaGFzQmluZGluZyhuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZS5oYXMobmFtZSk7XG4gIH1cblxuICBjaGlsZChibG9ja1BhcmFtczogc3RyaW5nW10pOiBCbG9ja0NvbnRleHQ8QmxvY2tTeW1ib2xUYWJsZT4ge1xuICAgIHJldHVybiBuZXcgQmxvY2tDb250ZXh0KHRoaXMuc291cmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMudGFibGUuY2hpbGQoYmxvY2tQYXJhbXMpKTtcbiAgfVxuXG4gIGN1c3RvbWl6ZUNvbXBvbmVudE5hbWUoaW5wdXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jdXN0b21pemVDb21wb25lbnROYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmN1c3RvbWl6ZUNvbXBvbmVudE5hbWUoaW5wdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gYEV4cHJlc3Npb25Ob3JtYWxpemVyYCBub3JtYWxpemVzIGV4cHJlc3Npb25zIHdpdGhpbiBhIGJsb2NrLlxuICpcbiAqIGBFeHByZXNzaW9uTm9ybWFsaXplcmAgaXMgc3RhdGVsZXNzLlxuICovXG5jbGFzcyBFeHByZXNzaW9uTm9ybWFsaXplciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYmxvY2s6IEJsb2NrQ29udGV4dCkge31cblxuICAvKipcbiAgICogVGhlIGBub3JtYWxpemVgIG1ldGhvZCB0YWtlcyBhbiBhcmJpdHJhcnkgZXhwcmVzc2lvbiBhbmQgaXRzIG9yaWdpbmFsIHN5bnRheCBjb250ZXh0IGFuZFxuICAgKiBub3JtYWxpemVzIGl0IHRvIGFuIEFTVHYyIGV4cHJlc3Npb24uXG4gICAqXG4gICAqIEBzZWUge1N5bnRheENvbnRleHR9XG4gICAqL1xuICBub3JtYWxpemUoZXhwcjogQVNUdjEuTGl0ZXJhbCwgcmVzb2x1dGlvbjogQVNUdjIuRnJlZVZhclJlc29sdXRpb24pOiBBU1R2Mi5MaXRlcmFsRXhwcmVzc2lvbjtcbiAgbm9ybWFsaXplKFxuICAgIGV4cHI6IEFTVHYxLk1pbmltYWxQYXRoRXhwcmVzc2lvbixcbiAgICByZXNvbHV0aW9uOiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvblxuICApOiBBU1R2Mi5QYXRoRXhwcmVzc2lvbjtcbiAgbm9ybWFsaXplKGV4cHI6IEFTVHYxLlN1YkV4cHJlc3Npb24sIHJlc29sdXRpb246IEFTVHYyLkZyZWVWYXJSZXNvbHV0aW9uKTogQVNUdjIuQ2FsbEV4cHJlc3Npb247XG4gIG5vcm1hbGl6ZShleHByOiBBU1R2MS5FeHByZXNzaW9uLCByZXNvbHV0aW9uOiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvbik6IEFTVHYyLkV4cHJlc3Npb25Ob2RlO1xuICBub3JtYWxpemUoXG4gICAgZXhwcjogQVNUdjEuRXhwcmVzc2lvbiB8IEFTVHYxLk1pbmltYWxQYXRoRXhwcmVzc2lvbixcbiAgICByZXNvbHV0aW9uOiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvblxuICApOiBBU1R2Mi5FeHByZXNzaW9uTm9kZSB7XG4gICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgIGNhc2UgJ051bGxMaXRlcmFsJzpcbiAgICAgIGNhc2UgJ0Jvb2xlYW5MaXRlcmFsJzpcbiAgICAgIGNhc2UgJ051bWJlckxpdGVyYWwnOlxuICAgICAgY2FzZSAnU3RyaW5nTGl0ZXJhbCc6XG4gICAgICBjYXNlICdVbmRlZmluZWRMaXRlcmFsJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2suYnVpbGRlci5saXRlcmFsKGV4cHIudmFsdWUsIHRoaXMuYmxvY2subG9jKGV4cHIubG9jKSk7XG4gICAgICBjYXNlICdQYXRoRXhwcmVzc2lvbic6XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgoZXhwciwgcmVzb2x1dGlvbik7XG4gICAgICBjYXNlICdTdWJFeHByZXNzaW9uJzoge1xuICAgICAgICBsZXQgcmVzb2x1dGlvbiA9IHRoaXMuYmxvY2sucmVzb2x1dGlvbkZvcihleHByLCBTZXhwU3ludGF4Q29udGV4dCk7XG5cbiAgICAgICAgaWYgKHJlc29sdXRpb24ucmVzb2x1dGlvbiA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgICBgWW91IGF0dGVtcHRlZCB0byBpbnZva2UgYSBwYXRoIChcXGAke3Jlc29sdXRpb24ucGF0aH1cXGApIGJ1dCAke3Jlc29sdXRpb24uaGVhZH0gd2FzIG5vdCBpbiBzY29wZWAsXG4gICAgICAgICAgICBleHByLmxvY1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLnNleHAoXG4gICAgICAgICAgdGhpcy5jYWxsUGFydHMoZXhwciwgcmVzb2x1dGlvbi5yZXNvbHV0aW9uKSxcbiAgICAgICAgICB0aGlzLmJsb2NrLmxvYyhleHByLmxvYylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBhdGgoXG4gICAgZXhwcjogQVNUdjEuTWluaW1hbFBhdGhFeHByZXNzaW9uLFxuICAgIHJlc29sdXRpb246IEFTVHYyLkZyZWVWYXJSZXNvbHV0aW9uXG4gICk6IEFTVHYyLlBhdGhFeHByZXNzaW9uIHtcbiAgICBsZXQgaGVhZE9mZnNldHMgPSB0aGlzLmJsb2NrLmxvYyhleHByLmhlYWQubG9jKTtcblxuICAgIGxldCB0YWlsID0gW107XG5cbiAgICAvLyBzdGFydCB3aXRoIHRoZSBoZWFkXG4gICAgbGV0IG9mZnNldCA9IGhlYWRPZmZzZXRzO1xuXG4gICAgZm9yIChsZXQgcGFydCBvZiBleHByLnRhaWwpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldC5zbGljZVN0YXJ0Q2hhcnMoeyBjaGFyczogcGFydC5sZW5ndGgsIHNraXBTdGFydDogMSB9KTtcbiAgICAgIHRhaWwucHVzaChcbiAgICAgICAgbmV3IFNvdXJjZVNsaWNlKHtcbiAgICAgICAgICBsb2M6IG9mZnNldCxcbiAgICAgICAgICBjaGFyczogcGFydCxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYmxvY2suYnVpbGRlci5wYXRoKHRoaXMucmVmKGV4cHIuaGVhZCwgcmVzb2x1dGlvbiksIHRhaWwsIHRoaXMuYmxvY2subG9jKGV4cHIubG9jKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGBjYWxsUGFydHNgIG1ldGhvZCB0YWtlcyBBU1R2MS5DYWxsUGFydHMgYXMgd2VsbCBhcyBhIHN5bnRheCBjb250ZXh0IGFuZCBub3JtYWxpemVzXG4gICAqIGl0IHRvIGFuIEFTVHYyIENhbGxQYXJ0cy5cbiAgICovXG4gIGNhbGxQYXJ0cyhwYXJ0czogQVNUdjEuQ2FsbFBhcnRzLCBjb250ZXh0OiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvbik6IENhbGxQYXJ0cyB7XG4gICAgbGV0IHsgcGF0aCwgcGFyYW1zLCBoYXNoIH0gPSBwYXJ0cztcblxuICAgIGxldCBjYWxsZWUgPSB0aGlzLm5vcm1hbGl6ZShwYXRoLCBjb250ZXh0KTtcbiAgICBsZXQgcGFyYW1MaXN0ID0gcGFyYW1zLm1hcCgocCkgPT4gdGhpcy5ub3JtYWxpemUocCwgQVNUdjIuQVJHVU1FTlRfUkVTT0xVVElPTikpO1xuICAgIGxldCBwYXJhbUxvYyA9IFNwYW5MaXN0LnJhbmdlKHBhcmFtTGlzdCwgY2FsbGVlLmxvYy5jb2xsYXBzZSgnZW5kJykpO1xuICAgIGxldCBuYW1lZExvYyA9IHRoaXMuYmxvY2subG9jKGhhc2gubG9jKTtcbiAgICBsZXQgYXJnc0xvYyA9IFNwYW5MaXN0LnJhbmdlKFtwYXJhbUxvYywgbmFtZWRMb2NdKTtcblxuICAgIGxldCBwb3NpdGlvbmFsID0gdGhpcy5ibG9jay5idWlsZGVyLnBvc2l0aW9uYWwoXG4gICAgICBwYXJhbXMubWFwKChwKSA9PiB0aGlzLm5vcm1hbGl6ZShwLCBBU1R2Mi5BUkdVTUVOVF9SRVNPTFVUSU9OKSksXG4gICAgICBwYXJhbUxvY1xuICAgICk7XG5cbiAgICBsZXQgbmFtZWQgPSB0aGlzLmJsb2NrLmJ1aWxkZXIubmFtZWQoXG4gICAgICBoYXNoLnBhaXJzLm1hcCgocCkgPT4gdGhpcy5uYW1lZEFyZ3VtZW50KHApKSxcbiAgICAgIHRoaXMuYmxvY2subG9jKGhhc2gubG9jKVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2FsbGVlLFxuICAgICAgYXJnczogdGhpcy5ibG9jay5idWlsZGVyLmFyZ3MocG9zaXRpb25hbCwgbmFtZWQsIGFyZ3NMb2MpLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIG5hbWVkQXJndW1lbnQocGFpcjogQVNUdjEuSGFzaFBhaXIpOiBBU1R2Mi5OYW1lZEFyZ3VtZW50IHtcbiAgICBsZXQgb2Zmc2V0cyA9IHRoaXMuYmxvY2subG9jKHBhaXIubG9jKTtcblxuICAgIGxldCBrZXlPZmZzZXRzID0gb2Zmc2V0cy5zbGljZVN0YXJ0Q2hhcnMoeyBjaGFyczogcGFpci5rZXkubGVuZ3RoIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYmxvY2suYnVpbGRlci5uYW1lZEFyZ3VtZW50KFxuICAgICAgbmV3IFNvdXJjZVNsaWNlKHsgY2hhcnM6IHBhaXIua2V5LCBsb2M6IGtleU9mZnNldHMgfSksXG4gICAgICB0aGlzLm5vcm1hbGl6ZShwYWlyLnZhbHVlLCBBU1R2Mi5BUkdVTUVOVF9SRVNPTFVUSU9OKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGByZWZgIG1ldGhvZCBub3JtYWxpemVzIGFuIGBBU1R2MS5QYXRoSGVhZGAgaW50byBhbiBgQVNUdjIuVmFyaWFibGVSZWZlcmVuY2VgLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBleHRyZW1lbHkgaW1wb3J0YW50LCBiZWNhdXNlIGl0IGlzIHJlc3BvbnNpYmxlIGZvciBub3JtYWxpemluZyBmcmVlXG4gICAqIHZhcmlhYmxlcyBpbnRvIGFuIGFuIEFTVHYyLlBhdGhIZWFkICp3aXRoIGFwcHJvcHJpYXRlIGNvbnRleHQqLlxuICAgKlxuICAgKiBUaGUgc3ludGF4IGNvbnRleHQgaXMgb3JpZ2luYWxseSBkZXRlcm1pbmVkIGJ5IHRoZSBzeW50YWN0aWMgcG9zaXRpb24gdGhhdCB0aGlzIGBQYXRoSGVhZGBcbiAgICogY2FtZSBmcm9tLCBhbmQgaXMgdWx0aW1hdGVseSBhdHRhY2hlZCB0byB0aGUgYEFTVHYyLlZhcmlhYmxlUmVmZXJlbmNlYCBoZXJlLiBJbiBBU1R2MixcbiAgICogdGhlIGBWYXJpYWJsZVJlZmVyZW5jZWAgbm9kZSBiZWFycyBmdWxsIHJlc3BvbnNpYmlsaXR5IGZvciBsb29zZSBtb2RlIHJ1bGVzIHRoYXQgY29udHJvbFxuICAgKiB0aGUgYmVoYXZpb3Igb2YgZnJlZSB2YXJpYWJsZXMuXG4gICAqL1xuICBwcml2YXRlIHJlZihoZWFkOiBBU1R2MS5QYXRoSGVhZCwgcmVzb2x1dGlvbjogQVNUdjIuRnJlZVZhclJlc29sdXRpb24pOiBBU1R2Mi5WYXJpYWJsZVJlZmVyZW5jZSB7XG4gICAgbGV0IHsgYmxvY2sgfSA9IHRoaXM7XG4gICAgbGV0IHsgYnVpbGRlciwgdGFibGUgfSA9IGJsb2NrO1xuICAgIGxldCBvZmZzZXRzID0gYmxvY2subG9jKGhlYWQubG9jKTtcblxuICAgIHN3aXRjaCAoaGVhZC50eXBlKSB7XG4gICAgICBjYXNlICdUaGlzSGVhZCc6XG4gICAgICAgIHJldHVybiBidWlsZGVyLnNlbGYob2Zmc2V0cyk7XG4gICAgICBjYXNlICdBdEhlYWQnOiB7XG4gICAgICAgIGxldCBzeW1ib2wgPSB0YWJsZS5hbGxvY2F0ZU5hbWVkKGhlYWQubmFtZSk7XG4gICAgICAgIHJldHVybiBidWlsZGVyLmF0KGhlYWQubmFtZSwgc3ltYm9sLCBvZmZzZXRzKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ1ZhckhlYWQnOiB7XG4gICAgICAgIGlmIChibG9jay5oYXNCaW5kaW5nKGhlYWQubmFtZSkpIHtcbiAgICAgICAgICBsZXQgW3N5bWJvbCwgaXNSb290XSA9IHRhYmxlLmdldChoZWFkLm5hbWUpO1xuXG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmJ1aWxkZXIubG9jYWxWYXIoaGVhZC5uYW1lLCBzeW1ib2wsIGlzUm9vdCwgb2Zmc2V0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGNvbnRleHQgPSBibG9jay5zdHJpY3QgPyBBU1R2Mi5TVFJJQ1RfUkVTT0xVVElPTiA6IHJlc29sdXRpb247XG4gICAgICAgICAgbGV0IHN5bWJvbCA9IGJsb2NrLnRhYmxlLmFsbG9jYXRlRnJlZShoZWFkLm5hbWUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmJ1aWxkZXIuZnJlZVZhcih7XG4gICAgICAgICAgICBuYW1lOiBoZWFkLm5hbWUsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgc3ltYm9sLFxuICAgICAgICAgICAgbG9jOiBvZmZzZXRzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogYFRlbXBsYXRlTm9ybWFsaXplcmAgbm9ybWFsaXplcyB0b3AtbGV2ZWwgQVNUdjEgc3RhdGVtZW50cyB0byBBU1R2Mi5cbiAqL1xuY2xhc3MgU3RhdGVtZW50Tm9ybWFsaXplciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYmxvY2s6IEJsb2NrQ29udGV4dCkge31cblxuICBub3JtYWxpemUobm9kZTogQVNUdjEuU3RhdGVtZW50KTogQVNUdjIuQ29udGVudE5vZGUgfCBBU1R2Mi5OYW1lZEJsb2NrIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSAnUGFydGlhbFN0YXRlbWVudCc6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSGFuZGxlYmFycyBwYXJ0aWFsIHN5bnRheCAoe3s+IC4uLn19KSBpcyBub3QgYWxsb3dlZCBpbiBHbGltbWVyYCk7XG4gICAgICBjYXNlICdCbG9ja1N0YXRlbWVudCc6XG4gICAgICAgIHJldHVybiB0aGlzLkJsb2NrU3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSAnRWxlbWVudE5vZGUnOlxuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnROb3JtYWxpemVyKHRoaXMuYmxvY2spLkVsZW1lbnROb2RlKG5vZGUpO1xuICAgICAgY2FzZSAnTXVzdGFjaGVTdGF0ZW1lbnQnOlxuICAgICAgICByZXR1cm4gdGhpcy5NdXN0YWNoZVN0YXRlbWVudChub2RlKTtcblxuICAgICAgLy8gVGhlc2UgYXJlIHRoZSBzYW1lIGluIEFTVHYyXG4gICAgICBjYXNlICdNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQnOlxuICAgICAgICByZXR1cm4gdGhpcy5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQobm9kZSk7XG5cbiAgICAgIGNhc2UgJ0NvbW1lbnRTdGF0ZW1lbnQnOiB7XG4gICAgICAgIGxldCBsb2MgPSB0aGlzLmJsb2NrLmxvYyhub2RlLmxvYyk7XG4gICAgICAgIHJldHVybiBuZXcgQVNUdjIuSHRtbENvbW1lbnQoe1xuICAgICAgICAgIGxvYyxcbiAgICAgICAgICB0ZXh0OiBsb2Muc2xpY2UoeyBza2lwU3RhcnQ6IDQsIHNraXBFbmQ6IDMgfSkudG9TbGljZShub2RlLnZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ1RleHROb2RlJzpcbiAgICAgICAgcmV0dXJuIG5ldyBBU1R2Mi5IdG1sVGV4dCh7XG4gICAgICAgICAgbG9jOiB0aGlzLmJsb2NrLmxvYyhub2RlLmxvYyksXG4gICAgICAgICAgY2hhcnM6IG5vZGUuY2hhcnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIE11c3RhY2hlQ29tbWVudFN0YXRlbWVudChub2RlOiBBU1R2MS5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQpOiBBU1R2Mi5HbGltbWVyQ29tbWVudCB7XG4gICAgbGV0IGxvYyA9IHRoaXMuYmxvY2subG9jKG5vZGUubG9jKTtcbiAgICBsZXQgdGV4dExvYzogU291cmNlU3BhbjtcblxuICAgIGlmIChsb2MuYXNTdHJpbmcoKS5zbGljZSgwLCA1KSA9PT0gJ3t7IS0tJykge1xuICAgICAgdGV4dExvYyA9IGxvYy5zbGljZSh7IHNraXBTdGFydDogNSwgc2tpcEVuZDogNCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dExvYyA9IGxvYy5zbGljZSh7IHNraXBTdGFydDogMywgc2tpcEVuZDogMiB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFTVHYyLkdsaW1tZXJDb21tZW50KHtcbiAgICAgIGxvYyxcbiAgICAgIHRleHQ6IHRleHRMb2MudG9TbGljZShub2RlLnZhbHVlKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIGFuIEFTVHYxLk11c3RhY2hlU3RhdGVtZW50IHRvIGFuIEFTVHYyLkFwcGVuZFN0YXRlbWVudFxuICAgKi9cbiAgTXVzdGFjaGVTdGF0ZW1lbnQobXVzdGFjaGU6IEFTVHYxLk11c3RhY2hlU3RhdGVtZW50KTogQVNUdjIuQXBwZW5kQ29udGVudCB7XG4gICAgbGV0IHsgZXNjYXBlZCB9ID0gbXVzdGFjaGU7XG4gICAgbGV0IGxvYyA9IHRoaXMuYmxvY2subG9jKG11c3RhY2hlLmxvYyk7XG5cbiAgICAvLyBOb3JtYWxpemUgdGhlIGNhbGwgcGFydHMgaW4gQXBwZW5kU3ludGF4Q29udGV4dFxuICAgIGxldCBjYWxsUGFydHMgPSB0aGlzLmV4cHIuY2FsbFBhcnRzKFxuICAgICAge1xuICAgICAgICBwYXRoOiBtdXN0YWNoZS5wYXRoLFxuICAgICAgICBwYXJhbXM6IG11c3RhY2hlLnBhcmFtcyxcbiAgICAgICAgaGFzaDogbXVzdGFjaGUuaGFzaCxcbiAgICAgIH0sXG4gICAgICBBcHBlbmRTeW50YXhDb250ZXh0KG11c3RhY2hlKVxuICAgICk7XG5cbiAgICBsZXQgdmFsdWUgPSBjYWxsUGFydHMuYXJncy5pc0VtcHR5KClcbiAgICAgID8gY2FsbFBhcnRzLmNhbGxlZVxuICAgICAgOiB0aGlzLmJsb2NrLmJ1aWxkZXIuc2V4cChjYWxsUGFydHMsIGxvYyk7XG5cbiAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLmFwcGVuZChcbiAgICAgIHtcbiAgICAgICAgdGFibGU6IHRoaXMuYmxvY2sudGFibGUsXG4gICAgICAgIHRydXN0aW5nOiAhZXNjYXBlZCxcbiAgICAgICAgdmFsdWUsXG4gICAgICB9LFxuICAgICAgbG9jXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIGEgQVNUdjEuQmxvY2tTdGF0ZW1lbnQgdG8gYW4gQVNUdjIuQmxvY2tTdGF0ZW1lbnRcbiAgICovXG4gIEJsb2NrU3RhdGVtZW50KGJsb2NrOiBBU1R2MS5CbG9ja1N0YXRlbWVudCk6IEFTVHYyLkludm9rZUJsb2NrIHtcbiAgICBsZXQgeyBwcm9ncmFtLCBpbnZlcnNlIH0gPSBibG9jaztcbiAgICBsZXQgbG9jID0gdGhpcy5ibG9jay5sb2MoYmxvY2subG9jKTtcblxuICAgIGxldCByZXNvbHV0aW9uID0gdGhpcy5ibG9jay5yZXNvbHV0aW9uRm9yKGJsb2NrLCBCbG9ja1N5bnRheENvbnRleHQpO1xuXG4gICAgaWYgKHJlc29sdXRpb24ucmVzb2x1dGlvbiA9PT0gJ2Vycm9yJykge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgYFlvdSBhdHRlbXB0ZWQgdG8gaW52b2tlIGEgcGF0aCAoXFxge3sjJHtyZXNvbHV0aW9uLnBhdGh9fX1cXGApIGJ1dCAke3Jlc29sdXRpb24uaGVhZH0gd2FzIG5vdCBpbiBzY29wZWAsXG4gICAgICAgIGxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgY2FsbFBhcnRzID0gdGhpcy5leHByLmNhbGxQYXJ0cyhibG9jaywgcmVzb2x1dGlvbi5yZXNvbHV0aW9uKTtcblxuICAgIHJldHVybiB0aGlzLmJsb2NrLmJ1aWxkZXIuYmxvY2tTdGF0ZW1lbnQoXG4gICAgICBhc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICBzeW1ib2xzOiB0aGlzLmJsb2NrLnRhYmxlLFxuICAgICAgICAgIHByb2dyYW06IHRoaXMuQmxvY2socHJvZ3JhbSksXG4gICAgICAgICAgaW52ZXJzZTogaW52ZXJzZSA/IHRoaXMuQmxvY2soaW52ZXJzZSkgOiBudWxsLFxuICAgICAgICB9LFxuICAgICAgICBjYWxsUGFydHNcbiAgICAgICksXG4gICAgICBsb2NcbiAgICApO1xuICB9XG5cbiAgQmxvY2soeyBib2R5LCBsb2MsIGJsb2NrUGFyYW1zIH06IEFTVHYxLkJsb2NrKTogQVNUdjIuQmxvY2sge1xuICAgIGxldCBjaGlsZCA9IHRoaXMuYmxvY2suY2hpbGQoYmxvY2tQYXJhbXMpO1xuICAgIGxldCBub3JtYWxpemVyID0gbmV3IFN0YXRlbWVudE5vcm1hbGl6ZXIoY2hpbGQpO1xuICAgIHJldHVybiBuZXcgQmxvY2tDaGlsZHJlbihcbiAgICAgIHRoaXMuYmxvY2subG9jKGxvYyksXG4gICAgICBib2R5Lm1hcCgoYikgPT4gbm9ybWFsaXplci5ub3JtYWxpemUoYikpLFxuICAgICAgdGhpcy5ibG9ja1xuICAgICkuYXNzZXJ0QmxvY2soY2hpbGQudGFibGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgZXhwcigpOiBFeHByZXNzaW9uTm9ybWFsaXplciB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uTm9ybWFsaXplcih0aGlzLmJsb2NrKTtcbiAgfVxufVxuXG5jbGFzcyBFbGVtZW50Tm9ybWFsaXplciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgY3R4OiBCbG9ja0NvbnRleHQpIHt9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgYW4gQVNUdjEuRWxlbWVudE5vZGUgdG86XG4gICAqXG4gICAqIC0gQVNUdjIuTmFtZWRCbG9jayBpZiB0aGUgdGFnIG5hbWUgYmVnaW5zIHdpdGggYDpgXG4gICAqIC0gQVNUdjIuQ29tcG9uZW50IGlmIHRoZSB0YWcgbmFtZSBtYXRjaGVzIHRoZSBjb21wb25lbnQgaGV1cmlzdGljc1xuICAgKiAtIEFTVHYyLlNpbXBsZUVsZW1lbnQgaWYgdGhlIHRhZyBuYW1lIGRvZXNuJ3QgbWF0Y2ggdGhlIGNvbXBvbmVudCBoZXVyaXN0aWNzXG4gICAqXG4gICAqIEEgdGFnIG5hbWUgcmVwcmVzZW50cyBhIGNvbXBvbmVudCBpZjpcbiAgICpcbiAgICogLSBpdCBiZWdpbnMgd2l0aCBgQGBcbiAgICogLSBpdCBpcyBleGFjdGx5IGB0aGlzYCBvciBiZWdpbnMgd2l0aCBgdGhpcy5gXG4gICAqIC0gdGhlIHBhcnQgYmVmb3JlIHRoZSBmaXJzdCBgLmAgaXMgYSByZWZlcmVuY2UgdG8gYW4gaW4tc2NvcGUgdmFyaWFibGUgYmluZGluZ1xuICAgKiAtIGl0IGJlZ2lucyB3aXRoIGFuIHVwcGVyY2FzZSBjaGFyYWN0ZXJcbiAgICovXG4gIEVsZW1lbnROb2RlKGVsZW1lbnQ6IEFTVHYxLkVsZW1lbnROb2RlKTogQVNUdjIuRWxlbWVudE5vZGUge1xuICAgIGxldCB7IHRhZywgc2VsZkNsb3NpbmcsIGNvbW1lbnRzIH0gPSBlbGVtZW50O1xuICAgIGxldCBsb2MgPSB0aGlzLmN0eC5sb2MoZWxlbWVudC5sb2MpO1xuXG4gICAgbGV0IFt0YWdIZWFkLCAuLi5yZXN0XSA9IHRhZy5zcGxpdCgnLicpO1xuXG4gICAgLy8gdGhlIGhlYWQsIGF0dHJpYnV0ZXMgYW5kIG1vZGlmaWVycyBhcmUgaW4gdGhlIGN1cnJlbnQgc2NvcGVcbiAgICBsZXQgcGF0aCA9IHRoaXMuY2xhc3NpZnlUYWcodGFnSGVhZCwgcmVzdCwgZWxlbWVudC5sb2MpO1xuXG4gICAgbGV0IGF0dHJzID0gZWxlbWVudC5hdHRyaWJ1dGVzLmZpbHRlcigoYSkgPT4gYS5uYW1lWzBdICE9PSAnQCcpLm1hcCgoYSkgPT4gdGhpcy5hdHRyKGEpKTtcbiAgICBsZXQgYXJncyA9IGVsZW1lbnQuYXR0cmlidXRlcy5maWx0ZXIoKGEpID0+IGEubmFtZVswXSA9PT0gJ0AnKS5tYXAoKGEpID0+IHRoaXMuYXJnKGEpKTtcblxuICAgIGxldCBtb2RpZmllcnMgPSBlbGVtZW50Lm1vZGlmaWVycy5tYXAoKG0pID0+IHRoaXMubW9kaWZpZXIobSkpO1xuXG4gICAgLy8gdGhlIGVsZW1lbnQncyBibG9jayBwYXJhbXMgYXJlIGluIHNjb3BlIGZvciB0aGUgY2hpbGRyZW5cbiAgICBsZXQgY2hpbGQgPSB0aGlzLmN0eC5jaGlsZChlbGVtZW50LmJsb2NrUGFyYW1zKTtcbiAgICBsZXQgbm9ybWFsaXplciA9IG5ldyBTdGF0ZW1lbnROb3JtYWxpemVyKGNoaWxkKTtcblxuICAgIGxldCBjaGlsZE5vZGVzID0gZWxlbWVudC5jaGlsZHJlbi5tYXAoKHMpID0+IG5vcm1hbGl6ZXIubm9ybWFsaXplKHMpKTtcblxuICAgIGxldCBlbCA9IHRoaXMuY3R4LmJ1aWxkZXIuZWxlbWVudCh7XG4gICAgICBzZWxmQ2xvc2luZyxcbiAgICAgIGF0dHJzLFxuICAgICAgY29tcG9uZW50QXJnczogYXJncyxcbiAgICAgIG1vZGlmaWVycyxcbiAgICAgIGNvbW1lbnRzOiBjb21tZW50cy5tYXAoKGMpID0+IG5ldyBTdGF0ZW1lbnROb3JtYWxpemVyKHRoaXMuY3R4KS5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQoYykpLFxuICAgIH0pO1xuXG4gICAgbGV0IGNoaWxkcmVuID0gbmV3IEVsZW1lbnRDaGlsZHJlbihlbCwgbG9jLCBjaGlsZE5vZGVzLCB0aGlzLmN0eCk7XG5cbiAgICBsZXQgb2Zmc2V0cyA9IHRoaXMuY3R4LmxvYyhlbGVtZW50LmxvYyk7XG4gICAgbGV0IHRhZ09mZnNldHMgPSBvZmZzZXRzLnNsaWNlU3RhcnRDaGFycyh7IGNoYXJzOiB0YWcubGVuZ3RoLCBza2lwU3RhcnQ6IDEgfSk7XG5cbiAgICBpZiAocGF0aCA9PT0gJ0VsZW1lbnRIZWFkJykge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gJzonKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5hc3NlcnROYW1lZEJsb2NrKFxuICAgICAgICAgIHRhZ09mZnNldHMuc2xpY2UoeyBza2lwU3RhcnQ6IDEgfSkudG9TbGljZSh0YWcuc2xpY2UoMSkpLFxuICAgICAgICAgIGNoaWxkLnRhYmxlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4uYXNzZXJ0RWxlbWVudCh0YWdPZmZzZXRzLnRvU2xpY2UodGFnKSwgZWxlbWVudC5ibG9ja1BhcmFtcy5sZW5ndGggPiAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5zZWxmQ2xvc2luZykge1xuICAgICAgcmV0dXJuIGVsLnNlbGZDbG9zaW5nQ29tcG9uZW50KHBhdGgsIGxvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBibG9ja3MgPSBjaGlsZHJlbi5hc3NlcnRDb21wb25lbnQodGFnLCBjaGlsZC50YWJsZSwgZWxlbWVudC5ibG9ja1BhcmFtcy5sZW5ndGggPiAwKTtcbiAgICAgIHJldHVybiBlbC5jb21wb25lbnRXaXRoTmFtZWRCbG9ja3MocGF0aCwgYmxvY2tzLCBsb2MpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbW9kaWZpZXIobTogQVNUdjEuRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50KTogQVNUdjIuRWxlbWVudE1vZGlmaWVyIHtcbiAgICBsZXQgcmVzb2x1dGlvbiA9IHRoaXMuY3R4LnJlc29sdXRpb25Gb3IobSwgTW9kaWZpZXJTeW50YXhDb250ZXh0KTtcblxuICAgIGlmIChyZXNvbHV0aW9uLnJlc29sdXRpb24gPT09ICdlcnJvcicpIHtcbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgIGBZb3UgYXR0ZW1wdGVkIHRvIGludm9rZSBhIHBhdGggKFxcYHt7IyR7cmVzb2x1dGlvbi5wYXRofX19XFxgKSBhcyBhIG1vZGlmaWVyLCBidXQgJHtyZXNvbHV0aW9uLmhlYWR9IHdhcyBub3QgaW4gc2NvcGUuIFRyeSBhZGRpbmcgXFxgdGhpc1xcYCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwYXRoYCxcbiAgICAgICAgbS5sb2NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IGNhbGxQYXJ0cyA9IHRoaXMuZXhwci5jYWxsUGFydHMobSwgcmVzb2x1dGlvbi5yZXNvbHV0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5jdHguYnVpbGRlci5tb2RpZmllcihjYWxsUGFydHMsIHRoaXMuY3R4LmxvYyhtLmxvYykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgYXR0cmlidXRlIHZhbHVlcyB0aGF0IGFyZSBjdXJsaWVzLCBhcyB3ZWxsIGFzIGN1cmxpZXMgbmVzdGVkIGluc2lkZSBvZlxuICAgKiBpbnRlcnBvbGF0aW9uczpcbiAgICpcbiAgICogYGBgaGJzXG4gICAqIDxhIGhyZWY9e3t1cmx9fSAvPlxuICAgKiA8YSBocmVmPVwie3t1cmx9fS5odG1sXCIgLz5cbiAgICogYGBgXG4gICAqL1xuICBwcml2YXRlIG11c3RhY2hlQXR0cihtdXN0YWNoZTogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQpOiBBU1R2Mi5FeHByZXNzaW9uTm9kZSB7XG4gICAgLy8gTm9ybWFsaXplIHRoZSBjYWxsIHBhcnRzIGluIEF0dHJWYWx1ZVN5bnRheENvbnRleHRcbiAgICBsZXQgc2V4cCA9IHRoaXMuY3R4LmJ1aWxkZXIuc2V4cChcbiAgICAgIHRoaXMuZXhwci5jYWxsUGFydHMobXVzdGFjaGUsIEF0dHJWYWx1ZVN5bnRheENvbnRleHQobXVzdGFjaGUpKSxcbiAgICAgIHRoaXMuY3R4LmxvYyhtdXN0YWNoZS5sb2MpXG4gICAgKTtcblxuICAgIC8vIElmIHRoZXJlIGFyZSBubyBwYXJhbXMgb3IgaGFzaCwganVzdCByZXR1cm4gdGhlIGZ1bmN0aW9uIHBhcnQgYXMgaXRzIG93biBleHByZXNzaW9uXG4gICAgaWYgKHNleHAuYXJncy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBzZXhwLmNhbGxlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNleHA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGF0dHJQYXJ0IGlzIHRoZSBuYXJyb3dlZCBkb3duIGxpc3Qgb2YgdmFsaWQgYXR0cmlidXRlIHZhbHVlcyB0aGF0IGFyZSBhbHNvXG4gICAqIGFsbG93ZWQgYXMgYSBjb25jYXQgcGFydCAoeW91IGNhbid0IG5lc3QgY29uY2F0cykuXG4gICAqL1xuICBwcml2YXRlIGF0dHJQYXJ0KFxuICAgIHBhcnQ6IEFTVHYxLk11c3RhY2hlU3RhdGVtZW50IHwgQVNUdjEuVGV4dE5vZGVcbiAgKTogeyBleHByOiBBU1R2Mi5FeHByZXNzaW9uTm9kZTsgdHJ1c3Rpbmc6IGJvb2xlYW4gfSB7XG4gICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ011c3RhY2hlU3RhdGVtZW50JzpcbiAgICAgICAgcmV0dXJuIHsgZXhwcjogdGhpcy5tdXN0YWNoZUF0dHIocGFydCksIHRydXN0aW5nOiAhcGFydC5lc2NhcGVkIH07XG4gICAgICBjYXNlICdUZXh0Tm9kZSc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXhwcjogdGhpcy5jdHguYnVpbGRlci5saXRlcmFsKHBhcnQuY2hhcnMsIHRoaXMuY3R4LmxvYyhwYXJ0LmxvYykpLFxuICAgICAgICAgIHRydXN0aW5nOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXR0clZhbHVlKFxuICAgIHBhcnQ6IEFTVHYxLk11c3RhY2hlU3RhdGVtZW50IHwgQVNUdjEuVGV4dE5vZGUgfCBBU1R2MS5Db25jYXRTdGF0ZW1lbnRcbiAgKTogeyBleHByOiBBU1R2Mi5FeHByZXNzaW9uTm9kZTsgdHJ1c3Rpbmc6IGJvb2xlYW4gfSB7XG4gICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ0NvbmNhdFN0YXRlbWVudCc6IHtcbiAgICAgICAgbGV0IHBhcnRzID0gcGFydC5wYXJ0cy5tYXAoKHApID0+IHRoaXMuYXR0clBhcnQocCkuZXhwcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXhwcjogdGhpcy5jdHguYnVpbGRlci5pbnRlcnBvbGF0ZShwYXJ0cywgdGhpcy5jdHgubG9jKHBhcnQubG9jKSksXG4gICAgICAgICAgdHJ1c3Rpbmc6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0clBhcnQocGFydCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhdHRyKG06IEFTVHYxLkF0dHJOb2RlKTogQVNUdjIuSHRtbE9yU3BsYXRBdHRyIHtcbiAgICBhc3NlcnQobS5uYW1lWzBdICE9PSAnQCcsICdBbiBhdHRyIG5hbWUgbXVzdCBub3Qgc3RhcnQgd2l0aCBgQGAnKTtcblxuICAgIGlmIChtLm5hbWUgPT09ICcuLi5hdHRyaWJ1dGVzJykge1xuICAgICAgcmV0dXJuIHRoaXMuY3R4LmJ1aWxkZXIuc3BsYXRBdHRyKHRoaXMuY3R4LnRhYmxlLmFsbG9jYXRlQmxvY2soJ2F0dHJzJyksIHRoaXMuY3R4LmxvYyhtLmxvYykpO1xuICAgIH1cblxuICAgIGxldCBvZmZzZXRzID0gdGhpcy5jdHgubG9jKG0ubG9jKTtcbiAgICBsZXQgbmFtZVNsaWNlID0gb2Zmc2V0cy5zbGljZVN0YXJ0Q2hhcnMoeyBjaGFyczogbS5uYW1lLmxlbmd0aCB9KS50b1NsaWNlKG0ubmFtZSk7XG5cbiAgICBsZXQgdmFsdWUgPSB0aGlzLmF0dHJWYWx1ZShtLnZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5jdHguYnVpbGRlci5hdHRyKFxuICAgICAgeyBuYW1lOiBuYW1lU2xpY2UsIHZhbHVlOiB2YWx1ZS5leHByLCB0cnVzdGluZzogdmFsdWUudHJ1c3RpbmcgfSxcbiAgICAgIG9mZnNldHNcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBtYXliZURlcHJlY2F0ZWRDYWxsKFxuICAgIGFyZzogU291cmNlU2xpY2UsXG4gICAgcGFydDogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQgfCBBU1R2MS5UZXh0Tm9kZSB8IEFTVHYxLkNvbmNhdFN0YXRlbWVudFxuICApOiB7IGV4cHI6IEFTVHYyLkRlcHJlY2F0ZWRDYWxsRXhwcmVzc2lvbjsgdHJ1c3Rpbmc6IGJvb2xlYW4gfSB8IG51bGwge1xuICAgIGlmICh0aGlzLmN0eC5zdHJpY3QpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChwYXJ0LnR5cGUgIT09ICdNdXN0YWNoZVN0YXRlbWVudCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCB7IHBhdGggfSA9IHBhcnQ7XG5cbiAgICBpZiAocGF0aC50eXBlICE9PSAnUGF0aEV4cHJlc3Npb24nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocGF0aC5oZWFkLnR5cGUgIT09ICdWYXJIZWFkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHsgbmFtZSB9ID0gcGF0aC5oZWFkO1xuXG4gICAgaWYgKG5hbWUgPT09ICdoYXMtYmxvY2snIHx8IG5hbWUgPT09ICdoYXMtYmxvY2stcGFyYW1zJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY3R4Lmhhc0JpbmRpbmcobmFtZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChwYXRoLnRhaWwubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocGFydC5wYXJhbXMubGVuZ3RoICE9PSAwIHx8IHBhcnQuaGFzaC5wYWlycy5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBjb250ZXh0ID0gQVNUdjIuTG9vc2VNb2RlUmVzb2x1dGlvbi5hdHRyKCk7XG5cbiAgICBsZXQgY2FsbGVlID0gdGhpcy5jdHguYnVpbGRlci5mcmVlVmFyKHtcbiAgICAgIG5hbWUsXG4gICAgICBjb250ZXh0LFxuICAgICAgc3ltYm9sOiB0aGlzLmN0eC50YWJsZS5hbGxvY2F0ZUZyZWUobmFtZSwgY29udGV4dCksXG4gICAgICBsb2M6IHBhdGgubG9jLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cHI6IHRoaXMuY3R4LmJ1aWxkZXIuZGVwcmVjYXRlZENhbGwoYXJnLCBjYWxsZWUsIHBhcnQubG9jKSxcbiAgICAgIHRydXN0aW5nOiBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhcmcoYXJnOiBBU1R2MS5BdHRyTm9kZSk6IEFTVHYyLkNvbXBvbmVudEFyZyB7XG4gICAgYXNzZXJ0KGFyZy5uYW1lWzBdID09PSAnQCcsICdBbiBhcmcgbmFtZSBtdXN0IHN0YXJ0IHdpdGggYEBgJyk7XG5cbiAgICBsZXQgb2Zmc2V0cyA9IHRoaXMuY3R4LmxvYyhhcmcubG9jKTtcbiAgICBsZXQgbmFtZVNsaWNlID0gb2Zmc2V0cy5zbGljZVN0YXJ0Q2hhcnMoeyBjaGFyczogYXJnLm5hbWUubGVuZ3RoIH0pLnRvU2xpY2UoYXJnLm5hbWUpO1xuXG4gICAgbGV0IHZhbHVlID0gdGhpcy5tYXliZURlcHJlY2F0ZWRDYWxsKG5hbWVTbGljZSwgYXJnLnZhbHVlKSB8fCB0aGlzLmF0dHJWYWx1ZShhcmcudmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmN0eC5idWlsZGVyLmFyZyhcbiAgICAgIHsgbmFtZTogbmFtZVNsaWNlLCB2YWx1ZTogdmFsdWUuZXhwciwgdHJ1c3Rpbmc6IHZhbHVlLnRydXN0aW5nIH0sXG4gICAgICBvZmZzZXRzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNsYXNzaWZpZXMgdGhlIGhlYWQgb2YgYW4gQVNUdjEuRWxlbWVudCBpbnRvIGFuIEFTVHYyLlBhdGhIZWFkIChpZiB0aGVcbiAgICogZWxlbWVudCBpcyBhIGNvbXBvbmVudCkgb3IgYCdFbGVtZW50SGVhZCdgIChpZiB0aGUgZWxlbWVudCBpcyBhIHNpbXBsZSBlbGVtZW50KS5cbiAgICpcbiAgICogUnVsZXM6XG4gICAqXG4gICAqIDEuIElmIHRoZSB2YXJpYWJsZSBpcyBhbiBgQGFyZ2AsIHJldHVybiBhbiBgQXRIZWFkYFxuICAgKiAyLiBJZiB0aGUgdmFyaWFibGUgaXMgYHRoaXNgLCByZXR1cm4gYSBgVGhpc0hlYWRgXG4gICAqIDMuIElmIHRoZSB2YXJpYWJsZSBpcyBpbiB0aGUgY3VycmVudCBzY29wZTpcbiAgICogICBhLiBJZiB0aGUgc2NvcGUgaXMgdGhlIHJvb3Qgc2NvcGUsIHRoZW4gcmV0dXJuIGEgRnJlZSBgTG9jYWxWYXJIZWFkYFxuICAgKiAgIGIuIEVsc2UsIHJldHVybiBhIHN0YW5kYXJkIGBMb2NhbFZhckhlYWRgXG4gICAqIDQuIElmIHRoZSB0YWcgbmFtZSBpcyBhIHBhdGggYW5kIHRoZSB2YXJpYWJsZSBpcyBub3QgaW4gdGhlIGN1cnJlbnQgc2NvcGUsIFN5bnRheCBFcnJvclxuICAgKiA1LiBJZiB0aGUgdmFyaWFibGUgaXMgdXBwZXJjYXNlIHJldHVybiBhIEZyZWVWYXIoUmVzb2x2ZUFzQ29tcG9uZW50SGVhZClcbiAgICogNi4gT3RoZXJ3aXNlLCByZXR1cm4gYCdFbGVtZW50SGVhZCdgXG4gICAqL1xuICBwcml2YXRlIGNsYXNzaWZ5VGFnKFxuICAgIHZhcmlhYmxlOiBzdHJpbmcsXG4gICAgdGFpbDogc3RyaW5nW10sXG4gICAgbG9jOiBTb3VyY2VTcGFuXG4gICk6IEFTVHYyLkV4cHJlc3Npb25Ob2RlIHwgJ0VsZW1lbnRIZWFkJyB7XG4gICAgbGV0IHVwcGVyY2FzZSA9IGlzVXBwZXJDYXNlKHZhcmlhYmxlKTtcbiAgICBsZXQgaW5TY29wZSA9IHZhcmlhYmxlWzBdID09PSAnQCcgfHwgdmFyaWFibGUgPT09ICd0aGlzJyB8fCB0aGlzLmN0eC5oYXNCaW5kaW5nKHZhcmlhYmxlKTtcblxuICAgIGlmICh0aGlzLmN0eC5zdHJpY3QgJiYgIWluU2NvcGUpIHtcbiAgICAgIGlmICh1cHBlcmNhc2UpIHtcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgQXR0ZW1wdGVkIHRvIGludm9rZSBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgaW4gc2NvcGUgaW4gYSBzdHJpY3QgbW9kZSB0ZW1wbGF0ZSwgXFxgPCR7dmFyaWFibGV9PlxcYC4gSWYgeW91IHdhbnRlZCB0byBjcmVhdGUgYW4gZWxlbWVudCB3aXRoIHRoYXQgbmFtZSwgY29udmVydCBpdCB0byBsb3dlcmNhc2UgLSBcXGA8JHt2YXJpYWJsZS50b0xvd2VyQ2FzZSgpfT5cXGBgLFxuICAgICAgICAgIGxvY1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBJbiBzdHJpY3QgbW9kZSwgdmFsdWVzIGFyZSBhbHdheXMgZWxlbWVudHMgdW5sZXNzIHRoZXkgYXJlIGluIHNjb3BlXG4gICAgICByZXR1cm4gJ0VsZW1lbnRIZWFkJztcbiAgICB9XG5cbiAgICAvLyBTaW5jZSB0aGUgcGFyc2VyIGhhbmRlZCB1cyB0aGUgSFRNTCBlbGVtZW50IG5hbWUgYXMgYSBzdHJpbmcsIHdlIG5lZWRcbiAgICAvLyB0byBjb252ZXJ0IGl0IGludG8gYW4gQVNUdjEgcGF0aCBzbyBpdCBjYW4gYmUgcHJvY2Vzc2VkIHVzaW5nIHRoZVxuICAgIC8vIGV4cHJlc3Npb24gbm9ybWFsaXplci5cbiAgICBsZXQgaXNDb21wb25lbnQgPSBpblNjb3BlIHx8IHVwcGVyY2FzZTtcblxuICAgIGxldCB2YXJpYWJsZUxvYyA9IGxvYy5zbGljZVN0YXJ0Q2hhcnMoeyBza2lwU3RhcnQ6IDEsIGNoYXJzOiB2YXJpYWJsZS5sZW5ndGggfSk7XG5cbiAgICBsZXQgdGFpbExlbmd0aCA9IHRhaWwucmVkdWNlKChhY2N1bSwgcGFydCkgPT4gYWNjdW0gKyAxICsgcGFydC5sZW5ndGgsIDApO1xuICAgIGxldCBwYXRoRW5kID0gdmFyaWFibGVMb2MuZ2V0RW5kKCkubW92ZSh0YWlsTGVuZ3RoKTtcbiAgICBsZXQgcGF0aExvYyA9IHZhcmlhYmxlTG9jLndpdGhFbmQocGF0aEVuZCk7XG5cbiAgICBpZiAoaXNDb21wb25lbnQpIHtcbiAgICAgIGxldCBwYXRoID0gYi5wYXRoKHtcbiAgICAgICAgaGVhZDogYi5oZWFkKHZhcmlhYmxlLCB2YXJpYWJsZUxvYyksXG4gICAgICAgIHRhaWwsXG4gICAgICAgIGxvYzogcGF0aExvYyxcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgcmVzb2x1dGlvbiA9IHRoaXMuY3R4LnJlc29sdXRpb25Gb3IocGF0aCwgQ29tcG9uZW50U3ludGF4Q29udGV4dCk7XG5cbiAgICAgIGlmIChyZXNvbHV0aW9uLnJlc29sdXRpb24gPT09ICdlcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgWW91IGF0dGVtcHRlZCB0byBpbnZva2UgYSBwYXRoIChcXGA8JHtyZXNvbHV0aW9uLnBhdGh9PlxcYCkgYnV0ICR7cmVzb2x1dGlvbi5oZWFkfSB3YXMgbm90IGluIHNjb3BlYCxcbiAgICAgICAgICBsb2NcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uTm9ybWFsaXplcih0aGlzLmN0eCkubm9ybWFsaXplKHBhdGgsIHJlc29sdXRpb24ucmVzb2x1dGlvbik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHRhZyBuYW1lIHdhc24ndCBhIHZhbGlkIGNvbXBvbmVudCBidXQgY29udGFpbmVkIGEgYC5gLCBpdCdzXG4gICAgLy8gYSBzeW50YXggZXJyb3IuXG4gICAgaWYgKHRhaWwubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgYFlvdSB1c2VkICR7dmFyaWFibGV9LiR7dGFpbC5qb2luKCcuJyl9IGFzIGEgdGFnIG5hbWUsIGJ1dCAke3ZhcmlhYmxlfSBpcyBub3QgaW4gc2NvcGVgLFxuICAgICAgICBsb2NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuICdFbGVtZW50SGVhZCc7XG4gIH1cblxuICBwcml2YXRlIGdldCBleHByKCk6IEV4cHJlc3Npb25Ob3JtYWxpemVyIHtcbiAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25Ob3JtYWxpemVyKHRoaXMuY3R4KTtcbiAgfVxufVxuXG5jbGFzcyBDaGlsZHJlbiB7XG4gIHJlYWRvbmx5IG5hbWVkQmxvY2tzOiBBU1R2Mi5OYW1lZEJsb2NrW107XG4gIHJlYWRvbmx5IGhhc1NlbWFudGljQ29udGVudDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgbm9uQmxvY2tDaGlsZHJlbjogQVNUdjIuQ29udGVudE5vZGVbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBsb2M6IFNvdXJjZVNwYW4sXG4gICAgcmVhZG9ubHkgY2hpbGRyZW46IChBU1R2Mi5Db250ZW50Tm9kZSB8IEFTVHYyLk5hbWVkQmxvY2spW10sXG4gICAgcmVhZG9ubHkgYmxvY2s6IEJsb2NrQ29udGV4dFxuICApIHtcbiAgICB0aGlzLm5hbWVkQmxvY2tzID0gY2hpbGRyZW4uZmlsdGVyKChjKTogYyBpcyBBU1R2Mi5OYW1lZEJsb2NrID0+IGMgaW5zdGFuY2VvZiBBU1R2Mi5OYW1lZEJsb2NrKTtcbiAgICB0aGlzLmhhc1NlbWFudGljQ29udGVudCA9IEJvb2xlYW4oXG4gICAgICBjaGlsZHJlbi5maWx0ZXIoKGMpOiBjIGlzIEFTVHYyLkNvbnRlbnROb2RlID0+IHtcbiAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBBU1R2Mi5OYW1lZEJsb2NrKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYy50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnR2xpbW1lckNvbW1lbnQnOlxuICAgICAgICAgIGNhc2UgJ0h0bWxDb21tZW50JzpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBjYXNlICdIdG1sVGV4dCc6XG4gICAgICAgICAgICByZXR1cm4gIS9eXFxzKiQvLmV4ZWMoYy5jaGFycyk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KS5sZW5ndGhcbiAgICApO1xuICAgIHRoaXMubm9uQmxvY2tDaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihcbiAgICAgIChjKTogYyBpcyBBU1R2Mi5Db250ZW50Tm9kZSA9PiAhKGMgaW5zdGFuY2VvZiBBU1R2Mi5OYW1lZEJsb2NrKVxuICAgICk7XG4gIH1cbn1cblxuY2xhc3MgVGVtcGxhdGVDaGlsZHJlbiBleHRlbmRzIENoaWxkcmVuIHtcbiAgYXNzZXJ0VGVtcGxhdGUodGFibGU6IFByb2dyYW1TeW1ib2xUYWJsZSk6IEFTVHYyLlRlbXBsYXRlIHtcbiAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZWRCbG9ja3MpKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKGBVbmV4cGVjdGVkIG5hbWVkIGJsb2NrIGF0IHRoZSB0b3AtbGV2ZWwgb2YgYSB0ZW1wbGF0ZWAsIHRoaXMubG9jKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLnRlbXBsYXRlKHRhYmxlLCB0aGlzLm5vbkJsb2NrQ2hpbGRyZW4sIHRoaXMuYmxvY2subG9jKHRoaXMubG9jKSk7XG4gIH1cbn1cblxuY2xhc3MgQmxvY2tDaGlsZHJlbiBleHRlbmRzIENoaWxkcmVuIHtcbiAgYXNzZXJ0QmxvY2sodGFibGU6IEJsb2NrU3ltYm9sVGFibGUpOiBBU1R2Mi5CbG9jayB7XG4gICAgaWYgKGlzUHJlc2VudCh0aGlzLm5hbWVkQmxvY2tzKSkge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihgVW5leHBlY3RlZCBuYW1lZCBibG9jayBuZXN0ZWQgaW4gYSBub3JtYWwgYmxvY2tgLCB0aGlzLmxvYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYmxvY2suYnVpbGRlci5ibG9jayh0YWJsZSwgdGhpcy5ub25CbG9ja0NoaWxkcmVuLCB0aGlzLmxvYyk7XG4gIH1cbn1cblxuY2xhc3MgRWxlbWVudENoaWxkcmVuIGV4dGVuZHMgQ2hpbGRyZW4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVsOiBCdWlsZEVsZW1lbnQsXG4gICAgbG9jOiBTb3VyY2VTcGFuLFxuICAgIGNoaWxkcmVuOiAoQVNUdjIuQ29udGVudE5vZGUgfCBBU1R2Mi5OYW1lZEJsb2NrKVtdLFxuICAgIGJsb2NrOiBCbG9ja0NvbnRleHRcbiAgKSB7XG4gICAgc3VwZXIobG9jLCBjaGlsZHJlbiwgYmxvY2spO1xuICB9XG5cbiAgYXNzZXJ0TmFtZWRCbG9jayhuYW1lOiBTb3VyY2VTbGljZSwgdGFibGU6IEJsb2NrU3ltYm9sVGFibGUpOiBBU1R2Mi5OYW1lZEJsb2NrIHtcbiAgICBpZiAodGhpcy5lbC5iYXNlLnNlbGZDbG9zaW5nKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgPDoke25hbWUuY2hhcnN9Lz4gaXMgbm90IGEgdmFsaWQgbmFtZWQgYmxvY2s6IG5hbWVkIGJsb2NrcyBjYW5ub3QgYmUgc2VsZi1jbG9zaW5nYCxcbiAgICAgICAgdGhpcy5sb2NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzUHJlc2VudCh0aGlzLm5hbWVkQmxvY2tzKSkge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgYFVuZXhwZWN0ZWQgbmFtZWQgYmxvY2sgaW5zaWRlIDw6JHtuYW1lLmNoYXJzfT4gbmFtZWQgYmxvY2s6IG5hbWVkIGJsb2NrcyBjYW5ub3QgY29udGFpbiBuZXN0ZWQgbmFtZWQgYmxvY2tzYCxcbiAgICAgICAgdGhpcy5sb2NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0xvd2VyQ2FzZShuYW1lLmNoYXJzKSkge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgYDw6JHtuYW1lLmNoYXJzfT4gaXMgbm90IGEgdmFsaWQgbmFtZWQgYmxvY2ssIGFuZCBuYW1lZCBibG9ja3MgbXVzdCBiZWdpbiB3aXRoIGEgbG93ZXJjYXNlIGxldHRlcmAsXG4gICAgICAgIHRoaXMubG9jXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMuZWwuYmFzZS5hdHRycy5sZW5ndGggPiAwIHx8XG4gICAgICB0aGlzLmVsLmJhc2UuY29tcG9uZW50QXJncy5sZW5ndGggPiAwIHx8XG4gICAgICB0aGlzLmVsLmJhc2UubW9kaWZpZXJzLmxlbmd0aCA+IDBcbiAgICApIHtcbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgIGBuYW1lZCBibG9jayA8OiR7bmFtZS5jaGFyc30+IGNhbm5vdCBoYXZlIGF0dHJpYnV0ZXMsIGFyZ3VtZW50cywgb3IgbW9kaWZpZXJzYCxcbiAgICAgICAgdGhpcy5sb2NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IG9mZnNldHMgPSBTcGFuTGlzdC5yYW5nZSh0aGlzLm5vbkJsb2NrQ2hpbGRyZW4sIHRoaXMubG9jKTtcblxuICAgIHJldHVybiB0aGlzLmJsb2NrLmJ1aWxkZXIubmFtZWRCbG9jayhcbiAgICAgIG5hbWUsXG4gICAgICB0aGlzLmJsb2NrLmJ1aWxkZXIuYmxvY2sodGFibGUsIHRoaXMubm9uQmxvY2tDaGlsZHJlbiwgb2Zmc2V0cyksXG4gICAgICB0aGlzLmxvY1xuICAgICk7XG4gIH1cblxuICBhc3NlcnRFbGVtZW50KG5hbWU6IFNvdXJjZVNsaWNlLCBoYXNCbG9ja1BhcmFtczogYm9vbGVhbik6IEFTVHYyLlNpbXBsZUVsZW1lbnQge1xuICAgIGlmIChoYXNCbG9ja1BhcmFtcykge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgYFVuZXhwZWN0ZWQgYmxvY2sgcGFyYW1zIGluIDwke25hbWV9Pjogc2ltcGxlIGVsZW1lbnRzIGNhbm5vdCBoYXZlIGJsb2NrIHBhcmFtc2AsXG4gICAgICAgIHRoaXMubG9jXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpc1ByZXNlbnQodGhpcy5uYW1lZEJsb2NrcykpIHtcbiAgICAgIGxldCBuYW1lcyA9IHRoaXMubmFtZWRCbG9ja3MubWFwKChiKSA9PiBiLm5hbWUpO1xuXG4gICAgICBpZiAobmFtZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgYFVuZXhwZWN0ZWQgbmFtZWQgYmxvY2sgPDpmb28+IGluc2lkZSA8JHtuYW1lLmNoYXJzfT4gSFRNTCBlbGVtZW50YCxcbiAgICAgICAgICB0aGlzLmxvY1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHByaW50ZWROYW1lcyA9IG5hbWVzLm1hcCgobikgPT4gYDw6JHtuLmNoYXJzfT5gKS5qb2luKCcsICcpO1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBVbmV4cGVjdGVkIG5hbWVkIGJsb2NrcyBpbnNpZGUgPCR7bmFtZS5jaGFyc30+IEhUTUwgZWxlbWVudCAoJHtwcmludGVkTmFtZXN9KWAsXG4gICAgICAgICAgdGhpcy5sb2NcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lbC5zaW1wbGUobmFtZSwgdGhpcy5ub25CbG9ja0NoaWxkcmVuLCB0aGlzLmxvYyk7XG4gIH1cblxuICBhc3NlcnRDb21wb25lbnQoXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIHRhYmxlOiBCbG9ja1N5bWJvbFRhYmxlLFxuICAgIGhhc0Jsb2NrUGFyYW1zOiBib29sZWFuXG4gICk6IFByZXNlbnRBcnJheTxBU1R2Mi5OYW1lZEJsb2NrPiB7XG4gICAgaWYgKGlzUHJlc2VudCh0aGlzLm5hbWVkQmxvY2tzKSAmJiB0aGlzLmhhc1NlbWFudGljQ29udGVudCkge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgYFVuZXhwZWN0ZWQgY29udGVudCBpbnNpZGUgPCR7bmFtZX0+IGNvbXBvbmVudCBpbnZvY2F0aW9uOiB3aGVuIHVzaW5nIG5hbWVkIGJsb2NrcywgdGhlIHRhZyBjYW5ub3QgY29udGFpbiBvdGhlciBjb250ZW50YCxcbiAgICAgICAgdGhpcy5sb2NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzUHJlc2VudCh0aGlzLm5hbWVkQmxvY2tzKSkge1xuICAgICAgaWYgKGhhc0Jsb2NrUGFyYW1zKSB7XG4gICAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgYFVuZXhwZWN0ZWQgYmxvY2sgcGFyYW1zIGxpc3Qgb24gPCR7bmFtZX0+IGNvbXBvbmVudCBpbnZvY2F0aW9uOiB3aGVuIHBhc3NpbmcgbmFtZWQgYmxvY2tzLCB0aGUgaW52b2NhdGlvbiB0YWcgY2Fubm90IHRha2UgYmxvY2sgcGFyYW1zYCxcbiAgICAgICAgICB0aGlzLmxvY1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBsZXQgc2Vlbk5hbWVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgICAgIGZvciAobGV0IGJsb2NrIG9mIHRoaXMubmFtZWRCbG9ja3MpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBibG9jay5uYW1lLmNoYXJzO1xuXG4gICAgICAgIGlmIChzZWVuTmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICAgIGBDb21wb25lbnQgaGFkIHR3byBuYW1lZCBibG9ja3Mgd2l0aCB0aGUgc2FtZSBuYW1lLCBcXGA8OiR7bmFtZX0+XFxgLiBPbmx5IG9uZSBibG9jayB3aXRoIGEgZ2l2ZW4gbmFtZSBtYXkgYmUgcGFzc2VkYCxcbiAgICAgICAgICAgIHRoaXMubG9jXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAobmFtZSA9PT0gJ2ludmVyc2UnICYmIHNlZW5OYW1lcy5oYXMoJ2Vsc2UnKSkgfHxcbiAgICAgICAgICAobmFtZSA9PT0gJ2Vsc2UnICYmIHNlZW5OYW1lcy5oYXMoJ2ludmVyc2UnKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICAgIGBDb21wb25lbnQgaGFzIGJvdGggPDplbHNlPiBhbmQgPDppbnZlcnNlPiBibG9jay4gPDppbnZlcnNlPiBpcyBhbiBhbGlhcyBmb3IgPDplbHNlPmAsXG4gICAgICAgICAgICB0aGlzLmxvY1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWVuTmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5uYW1lZEJsb2NrcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdGhpcy5ibG9jay5idWlsZGVyLm5hbWVkQmxvY2soXG4gICAgICAgICAgU291cmNlU2xpY2Uuc3ludGhldGljKCdkZWZhdWx0JyksXG4gICAgICAgICAgdGhpcy5ibG9jay5idWlsZGVyLmJsb2NrKHRhYmxlLCB0aGlzLm5vbkJsb2NrQ2hpbGRyZW4sIHRoaXMubG9jKSxcbiAgICAgICAgICB0aGlzLmxvY1xuICAgICAgICApLFxuICAgICAgXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRQYXRoKG5vZGU6IEFTVHYxLlBhdGhFeHByZXNzaW9uIHwgQVNUdjEuQ2FsbE5vZGUpOiBzdHJpbmcge1xuICBpZiAobm9kZS50eXBlICE9PSAnUGF0aEV4cHJlc3Npb24nICYmIG5vZGUucGF0aC50eXBlID09PSAnUGF0aEV4cHJlc3Npb24nKSB7XG4gICAgcmV0dXJuIHByaW50UGF0aChub2RlLnBhdGgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgUHJpbnRlcih7IGVudGl0eUVuY29kaW5nOiAncmF3JyB9KS5wcmludChub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludEhlYWQobm9kZTogQVNUdjEuUGF0aEV4cHJlc3Npb24gfCBBU1R2MS5DYWxsTm9kZSk6IHN0cmluZyB7XG4gIGlmIChub2RlLnR5cGUgPT09ICdQYXRoRXhwcmVzc2lvbicpIHtcbiAgICBzd2l0Y2ggKG5vZGUuaGVhZC50eXBlKSB7XG4gICAgICBjYXNlICdBdEhlYWQnOlxuICAgICAgY2FzZSAnVmFySGVhZCc6XG4gICAgICAgIHJldHVybiBub2RlLmhlYWQubmFtZTtcbiAgICAgIGNhc2UgJ1RoaXNIZWFkJzpcbiAgICAgICAgcmV0dXJuICd0aGlzJztcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS5wYXRoLnR5cGUgPT09ICdQYXRoRXhwcmVzc2lvbicpIHtcbiAgICByZXR1cm4gcHJpbnRIZWFkKG5vZGUucGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBQcmludGVyKHsgZW50aXR5RW5jb2Rpbmc6ICdyYXcnIH0pLnByaW50KG5vZGUpO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9