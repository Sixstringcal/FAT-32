"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalize = normalize;
exports.BlockContext = void 0;

var _util = require("@glimmer/util");

var _printer = _interopRequireDefault(require("../generation/printer"));

var _tokenizerEventHandlers = require("../parser/tokenizer-event-handlers");

var _slice = require("../source/slice");

var _spanList = require("../source/span-list");

var _symbolTable = require("../symbol-table");

var _syntaxError = require("../syntax-error");

var _utils = require("../utils");

var _parserBuilders = _interopRequireDefault(require("../v1/parser-builders"));

var ASTv2 = _interopRequireWildcard(require("./api"));

var _builders = require("./builders");

var _looseResolution = require("./loose-resolution");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function normalize(source, options = {}) {
  var _a;

  let ast = (0, _tokenizerEventHandlers.preprocess)(source, options);
  let normalizeOptions = (0, _util.assign)({
    strictMode: false,
    locals: []
  }, options);

  let top = _symbolTable.SymbolTable.top(normalizeOptions.strictMode ? normalizeOptions.locals : [], (_a = // eslint-disable-next-line @typescript-eslint/unbound-method
  options.customizeComponentName) !== null && _a !== void 0 ? _a : name => name);

  let block = new BlockContext(source, normalizeOptions, top);
  let normalizer = new StatementNormalizer(block);
  let astV2 = new TemplateChildren(block.loc(ast.loc), ast.body.map(b => normalizer.normalize(b)), block).assertTemplate(top);
  let locals = top.getUsedTemplateLocals();
  return [astV2, locals];
}
/**
 * A `BlockContext` represents the block that a particular AST node is contained inside of.
 *
 * `BlockContext` is aware of template-wide options (such as strict mode), as well as the bindings
 * that are in-scope within that block.
 *
 * Concretely, it has the `PrecompileOptions` and current `SymbolTable`, and provides
 * facilities for working with those options.
 *
 * `BlockContext` is stateless.
 */


class BlockContext {
  constructor(source, options, table) {
    this.source = source;
    this.options = options;
    this.table = table;
    this.builder = new _builders.Builder();
  }

  get strict() {
    return this.options.strictMode || false;
  }

  loc(loc) {
    return this.source.spanFor(loc);
  }

  resolutionFor(node, resolution) {
    if (this.strict) {
      return {
        resolution: ASTv2.STRICT_RESOLUTION
      };
    }

    if (this.isFreeVar(node)) {
      let r = resolution(node);

      if (r === null) {
        return {
          resolution: 'error',
          path: printPath(node),
          head: printHead(node)
        };
      }

      return {
        resolution: r
      };
    } else {
      return {
        resolution: ASTv2.STRICT_RESOLUTION
      };
    }
  }

  isFreeVar(callee) {
    if (callee.type === 'PathExpression') {
      if (callee.head.type !== 'VarHead') {
        return false;
      }

      return !this.table.has(callee.head.name);
    } else if (callee.path.type === 'PathExpression') {
      return this.isFreeVar(callee.path);
    } else {
      return false;
    }
  }

  hasBinding(name) {
    return this.table.has(name);
  }

  child(blockParams) {
    return new BlockContext(this.source, this.options, this.table.child(blockParams));
  }

  customizeComponentName(input) {
    if (this.options.customizeComponentName) {
      return this.options.customizeComponentName(input);
    } else {
      return input;
    }
  }

}
/**
 * An `ExpressionNormalizer` normalizes expressions within a block.
 *
 * `ExpressionNormalizer` is stateless.
 */


exports.BlockContext = BlockContext;

class ExpressionNormalizer {
  constructor(block) {
    this.block = block;
  }

  normalize(expr, resolution) {
    switch (expr.type) {
      case 'NullLiteral':
      case 'BooleanLiteral':
      case 'NumberLiteral':
      case 'StringLiteral':
      case 'UndefinedLiteral':
        return this.block.builder.literal(expr.value, this.block.loc(expr.loc));

      case 'PathExpression':
        return this.path(expr, resolution);

      case 'SubExpression':
        {
          let resolution = this.block.resolutionFor(expr, _looseResolution.SexpSyntaxContext);

          if (resolution.resolution === 'error') {
            throw (0, _syntaxError.generateSyntaxError)(`You attempted to invoke a path (\`${resolution.path}\`) but ${resolution.head} was not in scope`, expr.loc);
          }

          return this.block.builder.sexp(this.callParts(expr, resolution.resolution), this.block.loc(expr.loc));
        }
    }
  }

  path(expr, resolution) {
    let headOffsets = this.block.loc(expr.head.loc);
    let tail = []; // start with the head

    let offset = headOffsets;

    for (let part of expr.tail) {
      offset = offset.sliceStartChars({
        chars: part.length,
        skipStart: 1
      });
      tail.push(new _slice.SourceSlice({
        loc: offset,
        chars: part
      }));
    }

    return this.block.builder.path(this.ref(expr.head, resolution), tail, this.block.loc(expr.loc));
  }
  /**
   * The `callParts` method takes ASTv1.CallParts as well as a syntax context and normalizes
   * it to an ASTv2 CallParts.
   */


  callParts(parts, context) {
    let {
      path,
      params,
      hash
    } = parts;
    let callee = this.normalize(path, context);
    let paramList = params.map(p => this.normalize(p, ASTv2.ARGUMENT_RESOLUTION));

    let paramLoc = _spanList.SpanList.range(paramList, callee.loc.collapse('end'));

    let namedLoc = this.block.loc(hash.loc);

    let argsLoc = _spanList.SpanList.range([paramLoc, namedLoc]);

    let positional = this.block.builder.positional(params.map(p => this.normalize(p, ASTv2.ARGUMENT_RESOLUTION)), paramLoc);
    let named = this.block.builder.named(hash.pairs.map(p => this.namedArgument(p)), this.block.loc(hash.loc));
    return {
      callee,
      args: this.block.builder.args(positional, named, argsLoc)
    };
  }

  namedArgument(pair) {
    let offsets = this.block.loc(pair.loc);
    let keyOffsets = offsets.sliceStartChars({
      chars: pair.key.length
    });
    return this.block.builder.namedArgument(new _slice.SourceSlice({
      chars: pair.key,
      loc: keyOffsets
    }), this.normalize(pair.value, ASTv2.ARGUMENT_RESOLUTION));
  }
  /**
   * The `ref` method normalizes an `ASTv1.PathHead` into an `ASTv2.VariableReference`.
   * This method is extremely important, because it is responsible for normalizing free
   * variables into an an ASTv2.PathHead *with appropriate context*.
   *
   * The syntax context is originally determined by the syntactic position that this `PathHead`
   * came from, and is ultimately attached to the `ASTv2.VariableReference` here. In ASTv2,
   * the `VariableReference` node bears full responsibility for loose mode rules that control
   * the behavior of free variables.
   */


  ref(head, resolution) {
    let {
      block
    } = this;
    let {
      builder,
      table
    } = block;
    let offsets = block.loc(head.loc);

    switch (head.type) {
      case 'ThisHead':
        return builder.self(offsets);

      case 'AtHead':
        {
          let symbol = table.allocateNamed(head.name);
          return builder.at(head.name, symbol, offsets);
        }

      case 'VarHead':
        {
          if (block.hasBinding(head.name)) {
            let [symbol, isRoot] = table.get(head.name);
            return block.builder.localVar(head.name, symbol, isRoot, offsets);
          } else {
            let context = block.strict ? ASTv2.STRICT_RESOLUTION : resolution;
            let symbol = block.table.allocateFree(head.name, context);
            return block.builder.freeVar({
              name: head.name,
              context,
              symbol,
              loc: offsets
            });
          }
        }
    }
  }

}
/**
 * `TemplateNormalizer` normalizes top-level ASTv1 statements to ASTv2.
 */


class StatementNormalizer {
  constructor(block) {
    this.block = block;
  }

  normalize(node) {
    switch (node.type) {
      case 'PartialStatement':
        throw new Error(`Handlebars partial syntax ({{> ...}}) is not allowed in Glimmer`);

      case 'BlockStatement':
        return this.BlockStatement(node);

      case 'ElementNode':
        return new ElementNormalizer(this.block).ElementNode(node);

      case 'MustacheStatement':
        return this.MustacheStatement(node);
      // These are the same in ASTv2

      case 'MustacheCommentStatement':
        return this.MustacheCommentStatement(node);

      case 'CommentStatement':
        {
          let loc = this.block.loc(node.loc);
          return new ASTv2.HtmlComment({
            loc,
            text: loc.slice({
              skipStart: 4,
              skipEnd: 3
            }).toSlice(node.value)
          });
        }

      case 'TextNode':
        return new ASTv2.HtmlText({
          loc: this.block.loc(node.loc),
          chars: node.chars
        });
    }
  }

  MustacheCommentStatement(node) {
    let loc = this.block.loc(node.loc);
    let textLoc;

    if (loc.asString().slice(0, 5) === '{{!--') {
      textLoc = loc.slice({
        skipStart: 5,
        skipEnd: 4
      });
    } else {
      textLoc = loc.slice({
        skipStart: 3,
        skipEnd: 2
      });
    }

    return new ASTv2.GlimmerComment({
      loc,
      text: textLoc.toSlice(node.value)
    });
  }
  /**
   * Normalizes an ASTv1.MustacheStatement to an ASTv2.AppendStatement
   */


  MustacheStatement(mustache) {
    let {
      escaped
    } = mustache;
    let loc = this.block.loc(mustache.loc); // Normalize the call parts in AppendSyntaxContext

    let callParts = this.expr.callParts({
      path: mustache.path,
      params: mustache.params,
      hash: mustache.hash
    }, (0, _looseResolution.AppendSyntaxContext)(mustache));
    let value = callParts.args.isEmpty() ? callParts.callee : this.block.builder.sexp(callParts, loc);
    return this.block.builder.append({
      table: this.block.table,
      trusting: !escaped,
      value
    }, loc);
  }
  /**
   * Normalizes a ASTv1.BlockStatement to an ASTv2.BlockStatement
   */


  BlockStatement(block) {
    let {
      program,
      inverse
    } = block;
    let loc = this.block.loc(block.loc);
    let resolution = this.block.resolutionFor(block, _looseResolution.BlockSyntaxContext);

    if (resolution.resolution === 'error') {
      throw (0, _syntaxError.generateSyntaxError)(`You attempted to invoke a path (\`{{#${resolution.path}}}\`) but ${resolution.head} was not in scope`, loc);
    }

    let callParts = this.expr.callParts(block, resolution.resolution);
    return this.block.builder.blockStatement((0, _util.assign)({
      symbols: this.block.table,
      program: this.Block(program),
      inverse: inverse ? this.Block(inverse) : null
    }, callParts), loc);
  }

  Block({
    body,
    loc,
    blockParams
  }) {
    let child = this.block.child(blockParams);
    let normalizer = new StatementNormalizer(child);
    return new BlockChildren(this.block.loc(loc), body.map(b => normalizer.normalize(b)), this.block).assertBlock(child.table);
  }

  get expr() {
    return new ExpressionNormalizer(this.block);
  }

}

class ElementNormalizer {
  constructor(ctx) {
    this.ctx = ctx;
  }
  /**
   * Normalizes an ASTv1.ElementNode to:
   *
   * - ASTv2.NamedBlock if the tag name begins with `:`
   * - ASTv2.Component if the tag name matches the component heuristics
   * - ASTv2.SimpleElement if the tag name doesn't match the component heuristics
   *
   * A tag name represents a component if:
   *
   * - it begins with `@`
   * - it is exactly `this` or begins with `this.`
   * - the part before the first `.` is a reference to an in-scope variable binding
   * - it begins with an uppercase character
   */


  ElementNode(element) {
    let {
      tag,
      selfClosing,
      comments
    } = element;
    let loc = this.ctx.loc(element.loc);
    let [tagHead, ...rest] = tag.split('.'); // the head, attributes and modifiers are in the current scope

    let path = this.classifyTag(tagHead, rest, element.loc);
    let attrs = element.attributes.filter(a => a.name[0] !== '@').map(a => this.attr(a));
    let args = element.attributes.filter(a => a.name[0] === '@').map(a => this.arg(a));
    let modifiers = element.modifiers.map(m => this.modifier(m)); // the element's block params are in scope for the children

    let child = this.ctx.child(element.blockParams);
    let normalizer = new StatementNormalizer(child);
    let childNodes = element.children.map(s => normalizer.normalize(s));
    let el = this.ctx.builder.element({
      selfClosing,
      attrs,
      componentArgs: args,
      modifiers,
      comments: comments.map(c => new StatementNormalizer(this.ctx).MustacheCommentStatement(c))
    });
    let children = new ElementChildren(el, loc, childNodes, this.ctx);
    let offsets = this.ctx.loc(element.loc);
    let tagOffsets = offsets.sliceStartChars({
      chars: tag.length,
      skipStart: 1
    });

    if (path === 'ElementHead') {
      if (tag[0] === ':') {
        return children.assertNamedBlock(tagOffsets.slice({
          skipStart: 1
        }).toSlice(tag.slice(1)), child.table);
      } else {
        return children.assertElement(tagOffsets.toSlice(tag), element.blockParams.length > 0);
      }
    }

    if (element.selfClosing) {
      return el.selfClosingComponent(path, loc);
    } else {
      let blocks = children.assertComponent(tag, child.table, element.blockParams.length > 0);
      return el.componentWithNamedBlocks(path, blocks, loc);
    }
  }

  modifier(m) {
    let resolution = this.ctx.resolutionFor(m, _looseResolution.ModifierSyntaxContext);

    if (resolution.resolution === 'error') {
      throw (0, _syntaxError.generateSyntaxError)(`You attempted to invoke a path (\`{{#${resolution.path}}}\`) as a modifier, but ${resolution.head} was not in scope. Try adding \`this\` to the beginning of the path`, m.loc);
    }

    let callParts = this.expr.callParts(m, resolution.resolution);
    return this.ctx.builder.modifier(callParts, this.ctx.loc(m.loc));
  }
  /**
   * This method handles attribute values that are curlies, as well as curlies nested inside of
   * interpolations:
   *
   * ```hbs
   * <a href={{url}} />
   * <a href="{{url}}.html" />
   * ```
   */


  mustacheAttr(mustache) {
    // Normalize the call parts in AttrValueSyntaxContext
    let sexp = this.ctx.builder.sexp(this.expr.callParts(mustache, (0, _looseResolution.AttrValueSyntaxContext)(mustache)), this.ctx.loc(mustache.loc)); // If there are no params or hash, just return the function part as its own expression

    if (sexp.args.isEmpty()) {
      return sexp.callee;
    } else {
      return sexp;
    }
  }
  /**
   * attrPart is the narrowed down list of valid attribute values that are also
   * allowed as a concat part (you can't nest concats).
   */


  attrPart(part) {
    switch (part.type) {
      case 'MustacheStatement':
        return {
          expr: this.mustacheAttr(part),
          trusting: !part.escaped
        };

      case 'TextNode':
        return {
          expr: this.ctx.builder.literal(part.chars, this.ctx.loc(part.loc)),
          trusting: true
        };
    }
  }

  attrValue(part) {
    switch (part.type) {
      case 'ConcatStatement':
        {
          let parts = part.parts.map(p => this.attrPart(p).expr);
          return {
            expr: this.ctx.builder.interpolate(parts, this.ctx.loc(part.loc)),
            trusting: false
          };
        }

      default:
        return this.attrPart(part);
    }
  }

  attr(m) {
    false && (0, _util.assert)(m.name[0] !== '@', 'An attr name must not start with `@`');

    if (m.name === '...attributes') {
      return this.ctx.builder.splatAttr(this.ctx.table.allocateBlock('attrs'), this.ctx.loc(m.loc));
    }

    let offsets = this.ctx.loc(m.loc);
    let nameSlice = offsets.sliceStartChars({
      chars: m.name.length
    }).toSlice(m.name);
    let value = this.attrValue(m.value);
    return this.ctx.builder.attr({
      name: nameSlice,
      value: value.expr,
      trusting: value.trusting
    }, offsets);
  }

  maybeDeprecatedCall(arg, part) {
    if (this.ctx.strict) {
      return null;
    }

    if (part.type !== 'MustacheStatement') {
      return null;
    }

    let {
      path
    } = part;

    if (path.type !== 'PathExpression') {
      return null;
    }

    if (path.head.type !== 'VarHead') {
      return null;
    }

    let {
      name
    } = path.head;

    if (name === 'has-block' || name === 'has-block-params') {
      return null;
    }

    if (this.ctx.hasBinding(name)) {
      return null;
    }

    if (path.tail.length !== 0) {
      return null;
    }

    if (part.params.length !== 0 || part.hash.pairs.length !== 0) {
      return null;
    }

    let context = ASTv2.LooseModeResolution.attr();
    let callee = this.ctx.builder.freeVar({
      name,
      context,
      symbol: this.ctx.table.allocateFree(name, context),
      loc: path.loc
    });
    return {
      expr: this.ctx.builder.deprecatedCall(arg, callee, part.loc),
      trusting: false
    };
  }

  arg(arg) {
    false && (0, _util.assert)(arg.name[0] === '@', 'An arg name must start with `@`');
    let offsets = this.ctx.loc(arg.loc);
    let nameSlice = offsets.sliceStartChars({
      chars: arg.name.length
    }).toSlice(arg.name);
    let value = this.maybeDeprecatedCall(nameSlice, arg.value) || this.attrValue(arg.value);
    return this.ctx.builder.arg({
      name: nameSlice,
      value: value.expr,
      trusting: value.trusting
    }, offsets);
  }
  /**
   * This function classifies the head of an ASTv1.Element into an ASTv2.PathHead (if the
   * element is a component) or `'ElementHead'` (if the element is a simple element).
   *
   * Rules:
   *
   * 1. If the variable is an `@arg`, return an `AtHead`
   * 2. If the variable is `this`, return a `ThisHead`
   * 3. If the variable is in the current scope:
   *   a. If the scope is the root scope, then return a Free `LocalVarHead`
   *   b. Else, return a standard `LocalVarHead`
   * 4. If the tag name is a path and the variable is not in the current scope, Syntax Error
   * 5. If the variable is uppercase return a FreeVar(ResolveAsComponentHead)
   * 6. Otherwise, return `'ElementHead'`
   */


  classifyTag(variable, tail, loc) {
    let uppercase = (0, _utils.isUpperCase)(variable);
    let inScope = variable[0] === '@' || variable === 'this' || this.ctx.hasBinding(variable);

    if (this.ctx.strict && !inScope) {
      if (uppercase) {
        throw (0, _syntaxError.generateSyntaxError)(`Attempted to invoke a component that was not in scope in a strict mode template, \`<${variable}>\`. If you wanted to create an element with that name, convert it to lowercase - \`<${variable.toLowerCase()}>\``, loc);
      } // In strict mode, values are always elements unless they are in scope


      return 'ElementHead';
    } // Since the parser handed us the HTML element name as a string, we need
    // to convert it into an ASTv1 path so it can be processed using the
    // expression normalizer.


    let isComponent = inScope || uppercase;
    let variableLoc = loc.sliceStartChars({
      skipStart: 1,
      chars: variable.length
    });
    let tailLength = tail.reduce((accum, part) => accum + 1 + part.length, 0);
    let pathEnd = variableLoc.getEnd().move(tailLength);
    let pathLoc = variableLoc.withEnd(pathEnd);

    if (isComponent) {
      let path = _parserBuilders.default.path({
        head: _parserBuilders.default.head(variable, variableLoc),
        tail,
        loc: pathLoc
      });

      let resolution = this.ctx.resolutionFor(path, _looseResolution.ComponentSyntaxContext);

      if (resolution.resolution === 'error') {
        throw (0, _syntaxError.generateSyntaxError)(`You attempted to invoke a path (\`<${resolution.path}>\`) but ${resolution.head} was not in scope`, loc);
      }

      return new ExpressionNormalizer(this.ctx).normalize(path, resolution.resolution);
    } // If the tag name wasn't a valid component but contained a `.`, it's
    // a syntax error.


    if (tail.length > 0) {
      throw (0, _syntaxError.generateSyntaxError)(`You used ${variable}.${tail.join('.')} as a tag name, but ${variable} is not in scope`, loc);
    }

    return 'ElementHead';
  }

  get expr() {
    return new ExpressionNormalizer(this.ctx);
  }

}

class Children {
  constructor(loc, children, block) {
    this.loc = loc;
    this.children = children;
    this.block = block;
    this.namedBlocks = children.filter(c => c instanceof ASTv2.NamedBlock);
    this.hasSemanticContent = Boolean(children.filter(c => {
      if (c instanceof ASTv2.NamedBlock) {
        return false;
      }

      switch (c.type) {
        case 'GlimmerComment':
        case 'HtmlComment':
          return false;

        case 'HtmlText':
          return !/^\s*$/.exec(c.chars);

        default:
          return true;
      }
    }).length);
    this.nonBlockChildren = children.filter(c => !(c instanceof ASTv2.NamedBlock));
  }

}

class TemplateChildren extends Children {
  assertTemplate(table) {
    if ((0, _util.isPresent)(this.namedBlocks)) {
      throw (0, _syntaxError.generateSyntaxError)(`Unexpected named block at the top-level of a template`, this.loc);
    }

    return this.block.builder.template(table, this.nonBlockChildren, this.block.loc(this.loc));
  }

}

class BlockChildren extends Children {
  assertBlock(table) {
    if ((0, _util.isPresent)(this.namedBlocks)) {
      throw (0, _syntaxError.generateSyntaxError)(`Unexpected named block nested in a normal block`, this.loc);
    }

    return this.block.builder.block(table, this.nonBlockChildren, this.loc);
  }

}

class ElementChildren extends Children {
  constructor(el, loc, children, block) {
    super(loc, children, block);
    this.el = el;
  }

  assertNamedBlock(name, table) {
    if (this.el.base.selfClosing) {
      throw (0, _syntaxError.generateSyntaxError)(`<:${name.chars}/> is not a valid named block: named blocks cannot be self-closing`, this.loc);
    }

    if ((0, _util.isPresent)(this.namedBlocks)) {
      throw (0, _syntaxError.generateSyntaxError)(`Unexpected named block inside <:${name.chars}> named block: named blocks cannot contain nested named blocks`, this.loc);
    }

    if (!(0, _utils.isLowerCase)(name.chars)) {
      throw (0, _syntaxError.generateSyntaxError)(`<:${name.chars}> is not a valid named block, and named blocks must begin with a lowercase letter`, this.loc);
    }

    if (this.el.base.attrs.length > 0 || this.el.base.componentArgs.length > 0 || this.el.base.modifiers.length > 0) {
      throw (0, _syntaxError.generateSyntaxError)(`named block <:${name.chars}> cannot have attributes, arguments, or modifiers`, this.loc);
    }

    let offsets = _spanList.SpanList.range(this.nonBlockChildren, this.loc);

    return this.block.builder.namedBlock(name, this.block.builder.block(table, this.nonBlockChildren, offsets), this.loc);
  }

  assertElement(name, hasBlockParams) {
    if (hasBlockParams) {
      throw (0, _syntaxError.generateSyntaxError)(`Unexpected block params in <${name}>: simple elements cannot have block params`, this.loc);
    }

    if ((0, _util.isPresent)(this.namedBlocks)) {
      let names = this.namedBlocks.map(b => b.name);

      if (names.length === 1) {
        throw (0, _syntaxError.generateSyntaxError)(`Unexpected named block <:foo> inside <${name.chars}> HTML element`, this.loc);
      } else {
        let printedNames = names.map(n => `<:${n.chars}>`).join(', ');
        throw (0, _syntaxError.generateSyntaxError)(`Unexpected named blocks inside <${name.chars}> HTML element (${printedNames})`, this.loc);
      }
    }

    return this.el.simple(name, this.nonBlockChildren, this.loc);
  }

  assertComponent(name, table, hasBlockParams) {
    if ((0, _util.isPresent)(this.namedBlocks) && this.hasSemanticContent) {
      throw (0, _syntaxError.generateSyntaxError)(`Unexpected content inside <${name}> component invocation: when using named blocks, the tag cannot contain other content`, this.loc);
    }

    if ((0, _util.isPresent)(this.namedBlocks)) {
      if (hasBlockParams) {
        throw (0, _syntaxError.generateSyntaxError)(`Unexpected block params list on <${name}> component invocation: when passing named blocks, the invocation tag cannot take block params`, this.loc);
      }

      let seenNames = new Set();

      for (let block of this.namedBlocks) {
        let name = block.name.chars;

        if (seenNames.has(name)) {
          throw (0, _syntaxError.generateSyntaxError)(`Component had two named blocks with the same name, \`<:${name}>\`. Only one block with a given name may be passed`, this.loc);
        }

        if (name === 'inverse' && seenNames.has('else') || name === 'else' && seenNames.has('inverse')) {
          throw (0, _syntaxError.generateSyntaxError)(`Component has both <:else> and <:inverse> block. <:inverse> is an alias for <:else>`, this.loc);
        }

        seenNames.add(name);
      }

      return this.namedBlocks;
    } else {
      return [this.block.builder.namedBlock(_slice.SourceSlice.synthetic('default'), this.block.builder.block(table, this.nonBlockChildren, this.loc), this.loc)];
    }
  }

}

function printPath(node) {
  if (node.type !== 'PathExpression' && node.path.type === 'PathExpression') {
    return printPath(node.path);
  } else {
    return new _printer.default({
      entityEncoding: 'raw'
    }).print(node);
  }
}

function printHead(node) {
  if (node.type === 'PathExpression') {
    switch (node.head.type) {
      case 'AtHead':
      case 'VarHead':
        return node.head.name;

      case 'ThisHead':
        return 'this';
    }
  } else if (node.path.type === 'PathExpression') {
    return printHead(node.path);
  } else {
    return new _printer.default({
      entityEncoding: 'raw'
    }).print(node);
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvdjItYS9ub3JtYWxpemUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFHQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7QUFVTSxTQUFBLFNBQUEsQ0FBQSxNQUFBLEVBRUosT0FBQSxHQUZJLEVBQUEsRUFFMkI7OztBQUUvQixNQUFJLEdBQUcsR0FBRyx3Q0FBVSxNQUFWLEVBQVYsT0FBVSxDQUFWO0FBRUEsTUFBSSxnQkFBZ0IsR0FBRyxrQkFDckI7QUFDRSxJQUFBLFVBQVUsRUFEWixLQUFBO0FBRUUsSUFBQSxNQUFNLEVBQUU7QUFGVixHQURxQixFQUF2QixPQUF1QixDQUF2Qjs7QUFRQSxNQUFJLEdBQUcsR0FBRyx5QkFBQSxHQUFBLENBQ1IsZ0JBQWdCLENBQWhCLFVBQUEsR0FBOEIsZ0JBQWdCLENBQTlDLE1BQUEsR0FEUSxFQUFBLEVBQ2tELENBQUEsRUFBQSxHQUMxRDtBQUNBLEVBQUEsT0FBTyxDQUZtRCxzQkFBQSxNQUFBLElBQUEsSUFFNUIsRUFBQSxLQUFBLEtBRjRCLENBQUEsR0FBQSxFQUFBLEdBRXRCLElBQUQsSUFIckMsSUFBVSxDQUFWOztBQUtBLE1BQUksS0FBSyxHQUFHLElBQUEsWUFBQSxDQUFBLE1BQUEsRUFBQSxnQkFBQSxFQUFaLEdBQVksQ0FBWjtBQUNBLE1BQUksVUFBVSxHQUFHLElBQUEsbUJBQUEsQ0FBakIsS0FBaUIsQ0FBakI7QUFFQSxNQUFJLEtBQUssR0FBRyxJQUFBLGdCQUFBLENBQ1YsS0FBSyxDQUFMLEdBQUEsQ0FBVSxHQUFHLENBREgsR0FDVixDQURVLEVBRVYsR0FBRyxDQUFILElBQUEsQ0FBQSxHQUFBLENBQWMsQ0FBRCxJQUFPLFVBQVUsQ0FBVixTQUFBLENBRlYsQ0FFVSxDQUFwQixDQUZVLEVBQUEsS0FBQSxFQUFB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QUFBLENBQVAsSUFBTyxDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFBLFNBQUEsQ0FBQSxJQUFBLEVBQThEO0FBQzVELE1BQUksSUFBSSxDQUFKLElBQUEsS0FBSixnQkFBQSxFQUFvQztBQUNsQyxZQUFRLElBQUksQ0FBSixJQUFBLENBQVIsSUFBQTtBQUNFLFdBQUEsUUFBQTtBQUNBLFdBQUEsU0FBQTtBQUNFLGVBQU8sSUFBSSxDQUFKLElBQUEsQ0FBUCxJQUFBOztBQUNGLFdBQUEsVUFBQTtBQUNFLGVBQUEsTUFBQTtBQUxKO0FBREYsR0FBQSxNQVFPLElBQUksSUFBSSxDQUFKLElBQUEsQ0FBQSxJQUFBLEtBQUosZ0JBQUEsRUFBeUM7QUFDOUMsV0FBTyxTQUFTLENBQUMsSUFBSSxDQUFyQixJQUFnQixDQUFoQjtBQURLLEdBQUEsTUFFQTtBQUNMLFdBQU8sSUFBQSxnQkFBQSxDQUFZO0FBQUUsTUFBQSxjQUFjLEVBQUU7QUFBbEIsS0FBWixFQUFBLEtBQUEsQ0FBUCxJQUFPLENBQVA7QUFDRDtBQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJlc2VudEFycmF5IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2lnbiwgaXNQcmVzZW50IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmltcG9ydCBQcmludGVyIGZyb20gJy4uL2dlbmVyYXRpb24vcHJpbnRlcic7XG5pbXBvcnQgeyBQcmVjb21waWxlT3B0aW9ucywgcHJlcHJvY2VzcyB9IGZyb20gJy4uL3BhcnNlci90b2tlbml6ZXItZXZlbnQtaGFuZGxlcnMnO1xuaW1wb3J0IHsgU291cmNlTG9jYXRpb24gfSBmcm9tICcuLi9zb3VyY2UvbG9jYXRpb24nO1xuaW1wb3J0IHsgU291cmNlU2xpY2UgfSBmcm9tICcuLi9zb3VyY2Uvc2xpY2UnO1xuaW1wb3J0IHsgU291cmNlIH0gZnJvbSAnLi4vc291cmNlL3NvdXJjZSc7XG5pbXBvcnQgeyBTb3VyY2VTcGFuIH0gZnJvbSAnLi4vc291cmNlL3NwYW4nO1xuaW1wb3J0IHsgU3Bhbkxpc3QgfSBmcm9tICcuLi9zb3VyY2Uvc3Bhbi1saXN0JztcbmltcG9ydCB7IEJsb2NrU3ltYm9sVGFibGUsIFByb2dyYW1TeW1ib2xUYWJsZSwgU3ltYm9sVGFibGUgfSBmcm9tICcuLi9zeW1ib2wtdGFibGUnO1xuaW1wb3J0IHsgZ2VuZXJhdGVTeW50YXhFcnJvciB9IGZyb20gJy4uL3N5bnRheC1lcnJvcic7XG5pbXBvcnQgeyBpc0xvd2VyQ2FzZSwgaXNVcHBlckNhc2UgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgKiBhcyBBU1R2MSBmcm9tICcuLi92MS9hcGknO1xuaW1wb3J0IGIgZnJvbSAnLi4vdjEvcGFyc2VyLWJ1aWxkZXJzJztcbmltcG9ydCAqIGFzIEFTVHYyIGZyb20gJy4vYXBpJztcbmltcG9ydCB7IEJ1aWxkRWxlbWVudCwgQnVpbGRlciwgQ2FsbFBhcnRzIH0gZnJvbSAnLi9idWlsZGVycyc7XG5pbXBvcnQge1xuICBBcHBlbmRTeW50YXhDb250ZXh0LFxuICBBdHRyVmFsdWVTeW50YXhDb250ZXh0LFxuICBCbG9ja1N5bnRheENvbnRleHQsXG4gIENvbXBvbmVudFN5bnRheENvbnRleHQsXG4gIE1vZGlmaWVyU3ludGF4Q29udGV4dCxcbiAgUmVzb2x1dGlvbixcbiAgU2V4cFN5bnRheENvbnRleHQsXG59IGZyb20gJy4vbG9vc2UtcmVzb2x1dGlvbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUoXG4gIHNvdXJjZTogU291cmNlLFxuICBvcHRpb25zOiBQcmVjb21waWxlT3B0aW9ucyA9IHt9XG4pOiBbYXN0OiBBU1R2Mi5UZW1wbGF0ZSwgbG9jYWxzOiBzdHJpbmdbXV0ge1xuICBsZXQgYXN0ID0gcHJlcHJvY2Vzcyhzb3VyY2UsIG9wdGlvbnMpO1xuXG4gIGxldCBub3JtYWxpemVPcHRpb25zID0gYXNzaWduKFxuICAgIHtcbiAgICAgIHN0cmljdE1vZGU6IGZhbHNlLFxuICAgICAgbG9jYWxzOiBbXSxcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcblxuICBsZXQgdG9wID0gU3ltYm9sVGFibGUudG9wKFxuICAgIG5vcm1hbGl6ZU9wdGlvbnMuc3RyaWN0TW9kZSA/IG5vcm1hbGl6ZU9wdGlvbnMubG9jYWxzIDogW10sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgIG9wdGlvbnMuY3VzdG9taXplQ29tcG9uZW50TmFtZSA/PyAoKG5hbWUpID0+IG5hbWUpXG4gICk7XG4gIGxldCBibG9jayA9IG5ldyBCbG9ja0NvbnRleHQoc291cmNlLCBub3JtYWxpemVPcHRpb25zLCB0b3ApO1xuICBsZXQgbm9ybWFsaXplciA9IG5ldyBTdGF0ZW1lbnROb3JtYWxpemVyKGJsb2NrKTtcblxuICBsZXQgYXN0VjIgPSBuZXcgVGVtcGxhdGVDaGlsZHJlbihcbiAgICBibG9jay5sb2MoYXN0LmxvYyksXG4gICAgYXN0LmJvZHkubWFwKChiKSA9PiBub3JtYWxpemVyLm5vcm1hbGl6ZShiKSksXG4gICAgYmxvY2tcbiAgKS5hc3NlcnRUZW1wbGF0ZSh0b3ApO1xuXG4gIGxldCBsb2NhbHMgPSB0b3AuZ2V0VXNlZFRlbXBsYXRlTG9jYWxzKCk7XG5cbiAgcmV0dXJuIFthc3RWMiwgbG9jYWxzXTtcbn1cblxuLyoqXG4gKiBBIGBCbG9ja0NvbnRleHRgIHJlcHJlc2VudHMgdGhlIGJsb2NrIHRoYXQgYSBwYXJ0aWN1bGFyIEFTVCBub2RlIGlzIGNvbnRhaW5lZCBpbnNpZGUgb2YuXG4gKlxuICogYEJsb2NrQ29udGV4dGAgaXMgYXdhcmUgb2YgdGVtcGxhdGUtd2lkZSBvcHRpb25zIChzdWNoIGFzIHN0cmljdCBtb2RlKSwgYXMgd2VsbCBhcyB0aGUgYmluZGluZ3NcbiAqIHRoYXQgYXJlIGluLXNjb3BlIHdpdGhpbiB0aGF0IGJsb2NrLlxuICpcbiAqIENvbmNyZXRlbHksIGl0IGhhcyB0aGUgYFByZWNvbXBpbGVPcHRpb25zYCBhbmQgY3VycmVudCBgU3ltYm9sVGFibGVgLCBhbmQgcHJvdmlkZXNcbiAqIGZhY2lsaXRpZXMgZm9yIHdvcmtpbmcgd2l0aCB0aG9zZSBvcHRpb25zLlxuICpcbiAqIGBCbG9ja0NvbnRleHRgIGlzIHN0YXRlbGVzcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrQ29udGV4dDxUYWJsZSBleHRlbmRzIFN5bWJvbFRhYmxlID0gU3ltYm9sVGFibGU+IHtcbiAgcmVhZG9ubHkgYnVpbGRlcjogQnVpbGRlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBzb3VyY2U6IFNvdXJjZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnM6IFByZWNvbXBpbGVPcHRpb25zLFxuICAgIHJlYWRvbmx5IHRhYmxlOiBUYWJsZVxuICApIHtcbiAgICB0aGlzLmJ1aWxkZXIgPSBuZXcgQnVpbGRlcigpO1xuICB9XG5cbiAgZ2V0IHN0cmljdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnN0cmljdE1vZGUgfHwgZmFsc2U7XG4gIH1cblxuICBsb2MobG9jOiBTb3VyY2VMb2NhdGlvbik6IFNvdXJjZVNwYW4ge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5zcGFuRm9yKGxvYyk7XG4gIH1cblxuICByZXNvbHV0aW9uRm9yPE4gZXh0ZW5kcyBBU1R2MS5DYWxsTm9kZSB8IEFTVHYxLlBhdGhFeHByZXNzaW9uPihcbiAgICBub2RlOiBOLFxuICAgIHJlc29sdXRpb246IFJlc29sdXRpb248Tj5cbiAgKTogeyByZXNvbHV0aW9uOiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvbiB9IHwgeyByZXNvbHV0aW9uOiAnZXJyb3InOyBwYXRoOiBzdHJpbmc7IGhlYWQ6IHN0cmluZyB9IHtcbiAgICBpZiAodGhpcy5zdHJpY3QpIHtcbiAgICAgIHJldHVybiB7IHJlc29sdXRpb246IEFTVHYyLlNUUklDVF9SRVNPTFVUSU9OIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNGcmVlVmFyKG5vZGUpKSB7XG4gICAgICBsZXQgciA9IHJlc29sdXRpb24obm9kZSk7XG5cbiAgICAgIGlmIChyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzb2x1dGlvbjogJ2Vycm9yJyxcbiAgICAgICAgICBwYXRoOiBwcmludFBhdGgobm9kZSksXG4gICAgICAgICAgaGVhZDogcHJpbnRIZWFkKG5vZGUpLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyByZXNvbHV0aW9uOiByIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHJlc29sdXRpb246IEFTVHYyLlNUUklDVF9SRVNPTFVUSU9OIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpc0ZyZWVWYXIoY2FsbGVlOiBBU1R2MS5DYWxsTm9kZSB8IEFTVHYxLlBhdGhFeHByZXNzaW9uKTogYm9vbGVhbiB7XG4gICAgaWYgKGNhbGxlZS50eXBlID09PSAnUGF0aEV4cHJlc3Npb24nKSB7XG4gICAgICBpZiAoY2FsbGVlLmhlYWQudHlwZSAhPT0gJ1ZhckhlYWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICF0aGlzLnRhYmxlLmhhcyhjYWxsZWUuaGVhZC5uYW1lKTtcbiAgICB9IGVsc2UgaWYgKGNhbGxlZS5wYXRoLnR5cGUgPT09ICdQYXRoRXhwcmVzc2lvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzRnJlZVZhcihjYWxsZWUucGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBoYXNCaW5kaW5nKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnRhYmxlLmhhcyhuYW1lKTtcbiAgfVxuXG4gIGNoaWxkKGJsb2NrUGFyYW1zOiBzdHJpbmdbXSk6IEJsb2NrQ29udGV4dDxCbG9ja1N5bWJvbFRhYmxlPiB7XG4gICAgcmV0dXJuIG5ldyBCbG9ja0NvbnRleHQodGhpcy5zb3VyY2UsIHRoaXMub3B0aW9ucywgdGhpcy50YWJsZS5jaGlsZChibG9ja1BhcmFtcykpO1xuICB9XG5cbiAgY3VzdG9taXplQ29tcG9uZW50TmFtZShpbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmN1c3RvbWl6ZUNvbXBvbmVudE5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY3VzdG9taXplQ29tcG9uZW50TmFtZShpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBgRXhwcmVzc2lvbk5vcm1hbGl6ZXJgIG5vcm1hbGl6ZXMgZXhwcmVzc2lvbnMgd2l0aGluIGEgYmxvY2suXG4gKlxuICogYEV4cHJlc3Npb25Ob3JtYWxpemVyYCBpcyBzdGF0ZWxlc3MuXG4gKi9cbmNsYXNzIEV4cHJlc3Npb25Ob3JtYWxpemVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBibG9jazogQmxvY2tDb250ZXh0KSB7fVxuXG4gIC8qKlxuICAgKiBUaGUgYG5vcm1hbGl6ZWAgbWV0aG9kIHRha2VzIGFuIGFyYml0cmFyeSBleHByZXNzaW9uIGFuZCBpdHMgb3JpZ2luYWwgc3ludGF4IGNvbnRleHQgYW5kXG4gICAqIG5vcm1hbGl6ZXMgaXQgdG8gYW4gQVNUdjIgZXhwcmVzc2lvbi5cbiAgICpcbiAgICogQHNlZSB7U3ludGF4Q29udGV4dH1cbiAgICovXG4gIG5vcm1hbGl6ZShleHByOiBBU1R2MS5MaXRlcmFsLCByZXNvbHV0aW9uOiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvbik6IEFTVHYyLkxpdGVyYWxFeHByZXNzaW9uO1xuICBub3JtYWxpemUoXG4gICAgZXhwcjogQVNUdjEuTWluaW1hbFBhdGhFeHByZXNzaW9uLFxuICAgIHJlc29sdXRpb246IEFTVHYyLkZyZWVWYXJSZXNvbHV0aW9uXG4gICk6IEFTVHYyLlBhdGhFeHByZXNzaW9uO1xuICBub3JtYWxpemUoZXhwcjogQVNUdjEuU3ViRXhwcmVzc2lvbiwgcmVzb2x1dGlvbjogQVNUdjIuRnJlZVZhclJlc29sdXRpb24pOiBBU1R2Mi5DYWxsRXhwcmVzc2lvbjtcbiAgbm9ybWFsaXplKGV4cHI6IEFTVHYxLkV4cHJlc3Npb24sIHJlc29sdXRpb246IEFTVHYyLkZyZWVWYXJSZXNvbHV0aW9uKTogQVNUdjIuRXhwcmVzc2lvbk5vZGU7XG4gIG5vcm1hbGl6ZShcbiAgICBleHByOiBBU1R2MS5FeHByZXNzaW9uIHwgQVNUdjEuTWluaW1hbFBhdGhFeHByZXNzaW9uLFxuICAgIHJlc29sdXRpb246IEFTVHYyLkZyZWVWYXJSZXNvbHV0aW9uXG4gICk6IEFTVHYyLkV4cHJlc3Npb25Ob2RlIHtcbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgY2FzZSAnTnVsbExpdGVyYWwnOlxuICAgICAgY2FzZSAnQm9vbGVhbkxpdGVyYWwnOlxuICAgICAgY2FzZSAnTnVtYmVyTGl0ZXJhbCc6XG4gICAgICBjYXNlICdTdHJpbmdMaXRlcmFsJzpcbiAgICAgIGNhc2UgJ1VuZGVmaW5lZExpdGVyYWwnOlxuICAgICAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLmxpdGVyYWwoZXhwci52YWx1ZSwgdGhpcy5ibG9jay5sb2MoZXhwci5sb2MpKTtcbiAgICAgIGNhc2UgJ1BhdGhFeHByZXNzaW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aChleHByLCByZXNvbHV0aW9uKTtcbiAgICAgIGNhc2UgJ1N1YkV4cHJlc3Npb24nOiB7XG4gICAgICAgIGxldCByZXNvbHV0aW9uID0gdGhpcy5ibG9jay5yZXNvbHV0aW9uRm9yKGV4cHIsIFNleHBTeW50YXhDb250ZXh0KTtcblxuICAgICAgICBpZiAocmVzb2x1dGlvbi5yZXNvbHV0aW9uID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICAgIGBZb3UgYXR0ZW1wdGVkIHRvIGludm9rZSBhIHBhdGggKFxcYCR7cmVzb2x1dGlvbi5wYXRofVxcYCkgYnV0ICR7cmVzb2x1dGlvbi5oZWFkfSB3YXMgbm90IGluIHNjb3BlYCxcbiAgICAgICAgICAgIGV4cHIubG9jXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NrLmJ1aWxkZXIuc2V4cChcbiAgICAgICAgICB0aGlzLmNhbGxQYXJ0cyhleHByLCByZXNvbHV0aW9uLnJlc29sdXRpb24pLFxuICAgICAgICAgIHRoaXMuYmxvY2subG9jKGV4cHIubG9jKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGF0aChcbiAgICBleHByOiBBU1R2MS5NaW5pbWFsUGF0aEV4cHJlc3Npb24sXG4gICAgcmVzb2x1dGlvbjogQVNUdjIuRnJlZVZhclJlc29sdXRpb25cbiAgKTogQVNUdjIuUGF0aEV4cHJlc3Npb24ge1xuICAgIGxldCBoZWFkT2Zmc2V0cyA9IHRoaXMuYmxvY2subG9jKGV4cHIuaGVhZC5sb2MpO1xuXG4gICAgbGV0IHRhaWwgPSBbXTtcblxuICAgIC8vIHN0YXJ0IHdpdGggdGhlIGhlYWRcbiAgICBsZXQgb2Zmc2V0ID0gaGVhZE9mZnNldHM7XG5cbiAgICBmb3IgKGxldCBwYXJ0IG9mIGV4cHIudGFpbCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0LnNsaWNlU3RhcnRDaGFycyh7IGNoYXJzOiBwYXJ0Lmxlbmd0aCwgc2tpcFN0YXJ0OiAxIH0pO1xuICAgICAgdGFpbC5wdXNoKFxuICAgICAgICBuZXcgU291cmNlU2xpY2Uoe1xuICAgICAgICAgIGxvYzogb2Zmc2V0LFxuICAgICAgICAgIGNoYXJzOiBwYXJ0LFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLnBhdGgodGhpcy5yZWYoZXhwci5oZWFkLCByZXNvbHV0aW9uKSwgdGFpbCwgdGhpcy5ibG9jay5sb2MoZXhwci5sb2MpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYGNhbGxQYXJ0c2AgbWV0aG9kIHRha2VzIEFTVHYxLkNhbGxQYXJ0cyBhcyB3ZWxsIGFzIGEgc3ludGF4IGNvbnRleHQgYW5kIG5vcm1hbGl6ZXNcbiAgICogaXQgdG8gYW4gQVNUdjIgQ2FsbFBhcnRzLlxuICAgKi9cbiAgY2FsbFBhcnRzKHBhcnRzOiBBU1R2MS5DYWxsUGFydHMsIGNvbnRleHQ6IEFTVHYyLkZyZWVWYXJSZXNvbHV0aW9uKTogQ2FsbFBhcnRzIHtcbiAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IHBhcnRzO1xuXG4gICAgbGV0IGNhbGxlZSA9IHRoaXMubm9ybWFsaXplKHBhdGgsIGNvbnRleHQpO1xuICAgIGxldCBwYXJhbUxpc3QgPSBwYXJhbXMubWFwKChwKSA9PiB0aGlzLm5vcm1hbGl6ZShwLCBBU1R2Mi5BUkdVTUVOVF9SRVNPTFVUSU9OKSk7XG4gICAgbGV0IHBhcmFtTG9jID0gU3Bhbkxpc3QucmFuZ2UocGFyYW1MaXN0LCBjYWxsZWUubG9jLmNvbGxhcHNlKCdlbmQnKSk7XG4gICAgbGV0IG5hbWVkTG9jID0gdGhpcy5ibG9jay5sb2MoaGFzaC5sb2MpO1xuICAgIGxldCBhcmdzTG9jID0gU3Bhbkxpc3QucmFuZ2UoW3BhcmFtTG9jLCBuYW1lZExvY10pO1xuXG4gICAgbGV0IHBvc2l0aW9uYWwgPSB0aGlzLmJsb2NrLmJ1aWxkZXIucG9zaXRpb25hbChcbiAgICAgIHBhcmFtcy5tYXAoKHApID0+IHRoaXMubm9ybWFsaXplKHAsIEFTVHYyLkFSR1VNRU5UX1JFU09MVVRJT04pKSxcbiAgICAgIHBhcmFtTG9jXG4gICAgKTtcblxuICAgIGxldCBuYW1lZCA9IHRoaXMuYmxvY2suYnVpbGRlci5uYW1lZChcbiAgICAgIGhhc2gucGFpcnMubWFwKChwKSA9PiB0aGlzLm5hbWVkQXJndW1lbnQocCkpLFxuICAgICAgdGhpcy5ibG9jay5sb2MoaGFzaC5sb2MpXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBjYWxsZWUsXG4gICAgICBhcmdzOiB0aGlzLmJsb2NrLmJ1aWxkZXIuYXJncyhwb3NpdGlvbmFsLCBuYW1lZCwgYXJnc0xvYyksXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgbmFtZWRBcmd1bWVudChwYWlyOiBBU1R2MS5IYXNoUGFpcik6IEFTVHYyLk5hbWVkQXJndW1lbnQge1xuICAgIGxldCBvZmZzZXRzID0gdGhpcy5ibG9jay5sb2MocGFpci5sb2MpO1xuXG4gICAgbGV0IGtleU9mZnNldHMgPSBvZmZzZXRzLnNsaWNlU3RhcnRDaGFycyh7IGNoYXJzOiBwYWlyLmtleS5sZW5ndGggfSk7XG5cbiAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLm5hbWVkQXJndW1lbnQoXG4gICAgICBuZXcgU291cmNlU2xpY2UoeyBjaGFyczogcGFpci5rZXksIGxvYzoga2V5T2Zmc2V0cyB9KSxcbiAgICAgIHRoaXMubm9ybWFsaXplKHBhaXIudmFsdWUsIEFTVHYyLkFSR1VNRU5UX1JFU09MVVRJT04pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYHJlZmAgbWV0aG9kIG5vcm1hbGl6ZXMgYW4gYEFTVHYxLlBhdGhIZWFkYCBpbnRvIGFuIGBBU1R2Mi5WYXJpYWJsZVJlZmVyZW5jZWAuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGV4dHJlbWVseSBpbXBvcnRhbnQsIGJlY2F1c2UgaXQgaXMgcmVzcG9uc2libGUgZm9yIG5vcm1hbGl6aW5nIGZyZWVcbiAgICogdmFyaWFibGVzIGludG8gYW4gYW4gQVNUdjIuUGF0aEhlYWQgKndpdGggYXBwcm9wcmlhdGUgY29udGV4dCouXG4gICAqXG4gICAqIFRoZSBzeW50YXggY29udGV4dCBpcyBvcmlnaW5hbGx5IGRldGVybWluZWQgYnkgdGhlIHN5bnRhY3RpYyBwb3NpdGlvbiB0aGF0IHRoaXMgYFBhdGhIZWFkYFxuICAgKiBjYW1lIGZyb20sIGFuZCBpcyB1bHRpbWF0ZWx5IGF0dGFjaGVkIHRvIHRoZSBgQVNUdjIuVmFyaWFibGVSZWZlcmVuY2VgIGhlcmUuIEluIEFTVHYyLFxuICAgKiB0aGUgYFZhcmlhYmxlUmVmZXJlbmNlYCBub2RlIGJlYXJzIGZ1bGwgcmVzcG9uc2liaWxpdHkgZm9yIGxvb3NlIG1vZGUgcnVsZXMgdGhhdCBjb250cm9sXG4gICAqIHRoZSBiZWhhdmlvciBvZiBmcmVlIHZhcmlhYmxlcy5cbiAgICovXG4gIHByaXZhdGUgcmVmKGhlYWQ6IEFTVHYxLlBhdGhIZWFkLCByZXNvbHV0aW9uOiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvbik6IEFTVHYyLlZhcmlhYmxlUmVmZXJlbmNlIHtcbiAgICBsZXQgeyBibG9jayB9ID0gdGhpcztcbiAgICBsZXQgeyBidWlsZGVyLCB0YWJsZSB9ID0gYmxvY2s7XG4gICAgbGV0IG9mZnNldHMgPSBibG9jay5sb2MoaGVhZC5sb2MpO1xuXG4gICAgc3dpdGNoIChoZWFkLnR5cGUpIHtcbiAgICAgIGNhc2UgJ1RoaXNIZWFkJzpcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuc2VsZihvZmZzZXRzKTtcbiAgICAgIGNhc2UgJ0F0SGVhZCc6IHtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHRhYmxlLmFsbG9jYXRlTmFtZWQoaGVhZC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuYXQoaGVhZC5uYW1lLCBzeW1ib2wsIG9mZnNldHMpO1xuICAgICAgfVxuICAgICAgY2FzZSAnVmFySGVhZCc6IHtcbiAgICAgICAgaWYgKGJsb2NrLmhhc0JpbmRpbmcoaGVhZC5uYW1lKSkge1xuICAgICAgICAgIGxldCBbc3ltYm9sLCBpc1Jvb3RdID0gdGFibGUuZ2V0KGhlYWQubmFtZSk7XG5cbiAgICAgICAgICByZXR1cm4gYmxvY2suYnVpbGRlci5sb2NhbFZhcihoZWFkLm5hbWUsIHN5bWJvbCwgaXNSb290LCBvZmZzZXRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgY29udGV4dCA9IGJsb2NrLnN0cmljdCA/IEFTVHYyLlNUUklDVF9SRVNPTFVUSU9OIDogcmVzb2x1dGlvbjtcbiAgICAgICAgICBsZXQgc3ltYm9sID0gYmxvY2sudGFibGUuYWxsb2NhdGVGcmVlKGhlYWQubmFtZSwgY29udGV4dCk7XG5cbiAgICAgICAgICByZXR1cm4gYmxvY2suYnVpbGRlci5mcmVlVmFyKHtcbiAgICAgICAgICAgIG5hbWU6IGhlYWQubmFtZSxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBzeW1ib2wsXG4gICAgICAgICAgICBsb2M6IG9mZnNldHMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBgVGVtcGxhdGVOb3JtYWxpemVyYCBub3JtYWxpemVzIHRvcC1sZXZlbCBBU1R2MSBzdGF0ZW1lbnRzIHRvIEFTVHYyLlxuICovXG5jbGFzcyBTdGF0ZW1lbnROb3JtYWxpemVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBibG9jazogQmxvY2tDb250ZXh0KSB7fVxuXG4gIG5vcm1hbGl6ZShub2RlOiBBU1R2MS5TdGF0ZW1lbnQpOiBBU1R2Mi5Db250ZW50Tm9kZSB8IEFTVHYyLk5hbWVkQmxvY2sge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlICdQYXJ0aWFsU3RhdGVtZW50JzpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIYW5kbGViYXJzIHBhcnRpYWwgc3ludGF4ICh7ez4gLi4ufX0pIGlzIG5vdCBhbGxvd2VkIGluIEdsaW1tZXJgKTtcbiAgICAgIGNhc2UgJ0Jsb2NrU3RhdGVtZW50JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuQmxvY2tTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlICdFbGVtZW50Tm9kZSc6XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudE5vcm1hbGl6ZXIodGhpcy5ibG9jaykuRWxlbWVudE5vZGUobm9kZSk7XG4gICAgICBjYXNlICdNdXN0YWNoZVN0YXRlbWVudCc6XG4gICAgICAgIHJldHVybiB0aGlzLk11c3RhY2hlU3RhdGVtZW50KG5vZGUpO1xuXG4gICAgICAvLyBUaGVzZSBhcmUgdGhlIHNhbWUgaW4gQVNUdjJcbiAgICAgIGNhc2UgJ011c3RhY2hlQ29tbWVudFN0YXRlbWVudCc6XG4gICAgICAgIHJldHVybiB0aGlzLk11c3RhY2hlQ29tbWVudFN0YXRlbWVudChub2RlKTtcblxuICAgICAgY2FzZSAnQ29tbWVudFN0YXRlbWVudCc6IHtcbiAgICAgICAgbGV0IGxvYyA9IHRoaXMuYmxvY2subG9jKG5vZGUubG9jKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1R2Mi5IdG1sQ29tbWVudCh7XG4gICAgICAgICAgbG9jLFxuICAgICAgICAgIHRleHQ6IGxvYy5zbGljZSh7IHNraXBTdGFydDogNCwgc2tpcEVuZDogMyB9KS50b1NsaWNlKG5vZGUudmFsdWUpLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2FzZSAnVGV4dE5vZGUnOlxuICAgICAgICByZXR1cm4gbmV3IEFTVHYyLkh0bWxUZXh0KHtcbiAgICAgICAgICBsb2M6IHRoaXMuYmxvY2subG9jKG5vZGUubG9jKSxcbiAgICAgICAgICBjaGFyczogbm9kZS5jaGFycyxcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgTXVzdGFjaGVDb21tZW50U3RhdGVtZW50KG5vZGU6IEFTVHYxLk11c3RhY2hlQ29tbWVudFN0YXRlbWVudCk6IEFTVHYyLkdsaW1tZXJDb21tZW50IHtcbiAgICBsZXQgbG9jID0gdGhpcy5ibG9jay5sb2Mobm9kZS5sb2MpO1xuICAgIGxldCB0ZXh0TG9jOiBTb3VyY2VTcGFuO1xuXG4gICAgaWYgKGxvYy5hc1N0cmluZygpLnNsaWNlKDAsIDUpID09PSAne3shLS0nKSB7XG4gICAgICB0ZXh0TG9jID0gbG9jLnNsaWNlKHsgc2tpcFN0YXJ0OiA1LCBza2lwRW5kOiA0IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0TG9jID0gbG9jLnNsaWNlKHsgc2tpcFN0YXJ0OiAzLCBza2lwRW5kOiAyIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQVNUdjIuR2xpbW1lckNvbW1lbnQoe1xuICAgICAgbG9jLFxuICAgICAgdGV4dDogdGV4dExvYy50b1NsaWNlKG5vZGUudmFsdWUpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgYW4gQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQgdG8gYW4gQVNUdjIuQXBwZW5kU3RhdGVtZW50XG4gICAqL1xuICBNdXN0YWNoZVN0YXRlbWVudChtdXN0YWNoZTogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQpOiBBU1R2Mi5BcHBlbmRDb250ZW50IHtcbiAgICBsZXQgeyBlc2NhcGVkIH0gPSBtdXN0YWNoZTtcbiAgICBsZXQgbG9jID0gdGhpcy5ibG9jay5sb2MobXVzdGFjaGUubG9jKTtcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgY2FsbCBwYXJ0cyBpbiBBcHBlbmRTeW50YXhDb250ZXh0XG4gICAgbGV0IGNhbGxQYXJ0cyA9IHRoaXMuZXhwci5jYWxsUGFydHMoXG4gICAgICB7XG4gICAgICAgIHBhdGg6IG11c3RhY2hlLnBhdGgsXG4gICAgICAgIHBhcmFtczogbXVzdGFjaGUucGFyYW1zLFxuICAgICAgICBoYXNoOiBtdXN0YWNoZS5oYXNoLFxuICAgICAgfSxcbiAgICAgIEFwcGVuZFN5bnRheENvbnRleHQobXVzdGFjaGUpXG4gICAgKTtcblxuICAgIGxldCB2YWx1ZSA9IGNhbGxQYXJ0cy5hcmdzLmlzRW1wdHkoKVxuICAgICAgPyBjYWxsUGFydHMuY2FsbGVlXG4gICAgICA6IHRoaXMuYmxvY2suYnVpbGRlci5zZXhwKGNhbGxQYXJ0cywgbG9jKTtcblxuICAgIHJldHVybiB0aGlzLmJsb2NrLmJ1aWxkZXIuYXBwZW5kKFxuICAgICAge1xuICAgICAgICB0YWJsZTogdGhpcy5ibG9jay50YWJsZSxcbiAgICAgICAgdHJ1c3Rpbmc6ICFlc2NhcGVkLFxuICAgICAgICB2YWx1ZSxcbiAgICAgIH0sXG4gICAgICBsb2NcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgYSBBU1R2MS5CbG9ja1N0YXRlbWVudCB0byBhbiBBU1R2Mi5CbG9ja1N0YXRlbWVudFxuICAgKi9cbiAgQmxvY2tTdGF0ZW1lbnQoYmxvY2s6IEFTVHYxLkJsb2NrU3RhdGVtZW50KTogQVNUdjIuSW52b2tlQmxvY2sge1xuICAgIGxldCB7IHByb2dyYW0sIGludmVyc2UgfSA9IGJsb2NrO1xuICAgIGxldCBsb2MgPSB0aGlzLmJsb2NrLmxvYyhibG9jay5sb2MpO1xuXG4gICAgbGV0IHJlc29sdXRpb24gPSB0aGlzLmJsb2NrLnJlc29sdXRpb25Gb3IoYmxvY2ssIEJsb2NrU3ludGF4Q29udGV4dCk7XG5cbiAgICBpZiAocmVzb2x1dGlvbi5yZXNvbHV0aW9uID09PSAnZXJyb3InKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgWW91IGF0dGVtcHRlZCB0byBpbnZva2UgYSBwYXRoIChcXGB7eyMke3Jlc29sdXRpb24ucGF0aH19fVxcYCkgYnV0ICR7cmVzb2x1dGlvbi5oZWFkfSB3YXMgbm90IGluIHNjb3BlYCxcbiAgICAgICAgbG9jXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBjYWxsUGFydHMgPSB0aGlzLmV4cHIuY2FsbFBhcnRzKGJsb2NrLCByZXNvbHV0aW9uLnJlc29sdXRpb24pO1xuXG4gICAgcmV0dXJuIHRoaXMuYmxvY2suYnVpbGRlci5ibG9ja1N0YXRlbWVudChcbiAgICAgIGFzc2lnbihcbiAgICAgICAge1xuICAgICAgICAgIHN5bWJvbHM6IHRoaXMuYmxvY2sudGFibGUsXG4gICAgICAgICAgcHJvZ3JhbTogdGhpcy5CbG9jayhwcm9ncmFtKSxcbiAgICAgICAgICBpbnZlcnNlOiBpbnZlcnNlID8gdGhpcy5CbG9jayhpbnZlcnNlKSA6IG51bGwsXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGxQYXJ0c1xuICAgICAgKSxcbiAgICAgIGxvY1xuICAgICk7XG4gIH1cblxuICBCbG9jayh7IGJvZHksIGxvYywgYmxvY2tQYXJhbXMgfTogQVNUdjEuQmxvY2spOiBBU1R2Mi5CbG9jayB7XG4gICAgbGV0IGNoaWxkID0gdGhpcy5ibG9jay5jaGlsZChibG9ja1BhcmFtcyk7XG4gICAgbGV0IG5vcm1hbGl6ZXIgPSBuZXcgU3RhdGVtZW50Tm9ybWFsaXplcihjaGlsZCk7XG4gICAgcmV0dXJuIG5ldyBCbG9ja0NoaWxkcmVuKFxuICAgICAgdGhpcy5ibG9jay5sb2MobG9jKSxcbiAgICAgIGJvZHkubWFwKChiKSA9PiBub3JtYWxpemVyLm5vcm1hbGl6ZShiKSksXG4gICAgICB0aGlzLmJsb2NrXG4gICAgKS5hc3NlcnRCbG9jayhjaGlsZC50YWJsZSk7XG4gIH1cblxuICBwcml2YXRlIGdldCBleHByKCk6IEV4cHJlc3Npb25Ob3JtYWxpemVyIHtcbiAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25Ob3JtYWxpemVyKHRoaXMuYmxvY2spO1xuICB9XG59XG5cbmNsYXNzIEVsZW1lbnROb3JtYWxpemVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBjdHg6IEJsb2NrQ29udGV4dCkge31cblxuICAvKipcbiAgICogTm9ybWFsaXplcyBhbiBBU1R2MS5FbGVtZW50Tm9kZSB0bzpcbiAgICpcbiAgICogLSBBU1R2Mi5OYW1lZEJsb2NrIGlmIHRoZSB0YWcgbmFtZSBiZWdpbnMgd2l0aCBgOmBcbiAgICogLSBBU1R2Mi5Db21wb25lbnQgaWYgdGhlIHRhZyBuYW1lIG1hdGNoZXMgdGhlIGNvbXBvbmVudCBoZXVyaXN0aWNzXG4gICAqIC0gQVNUdjIuU2ltcGxlRWxlbWVudCBpZiB0aGUgdGFnIG5hbWUgZG9lc24ndCBtYXRjaCB0aGUgY29tcG9uZW50IGhldXJpc3RpY3NcbiAgICpcbiAgICogQSB0YWcgbmFtZSByZXByZXNlbnRzIGEgY29tcG9uZW50IGlmOlxuICAgKlxuICAgKiAtIGl0IGJlZ2lucyB3aXRoIGBAYFxuICAgKiAtIGl0IGlzIGV4YWN0bHkgYHRoaXNgIG9yIGJlZ2lucyB3aXRoIGB0aGlzLmBcbiAgICogLSB0aGUgcGFydCBiZWZvcmUgdGhlIGZpcnN0IGAuYCBpcyBhIHJlZmVyZW5jZSB0byBhbiBpbi1zY29wZSB2YXJpYWJsZSBiaW5kaW5nXG4gICAqIC0gaXQgYmVnaW5zIHdpdGggYW4gdXBwZXJjYXNlIGNoYXJhY3RlclxuICAgKi9cbiAgRWxlbWVudE5vZGUoZWxlbWVudDogQVNUdjEuRWxlbWVudE5vZGUpOiBBU1R2Mi5FbGVtZW50Tm9kZSB7XG4gICAgbGV0IHsgdGFnLCBzZWxmQ2xvc2luZywgY29tbWVudHMgfSA9IGVsZW1lbnQ7XG4gICAgbGV0IGxvYyA9IHRoaXMuY3R4LmxvYyhlbGVtZW50LmxvYyk7XG5cbiAgICBsZXQgW3RhZ0hlYWQsIC4uLnJlc3RdID0gdGFnLnNwbGl0KCcuJyk7XG5cbiAgICAvLyB0aGUgaGVhZCwgYXR0cmlidXRlcyBhbmQgbW9kaWZpZXJzIGFyZSBpbiB0aGUgY3VycmVudCBzY29wZVxuICAgIGxldCBwYXRoID0gdGhpcy5jbGFzc2lmeVRhZyh0YWdIZWFkLCByZXN0LCBlbGVtZW50LmxvYyk7XG5cbiAgICBsZXQgYXR0cnMgPSBlbGVtZW50LmF0dHJpYnV0ZXMuZmlsdGVyKChhKSA9PiBhLm5hbWVbMF0gIT09ICdAJykubWFwKChhKSA9PiB0aGlzLmF0dHIoYSkpO1xuICAgIGxldCBhcmdzID0gZWxlbWVudC5hdHRyaWJ1dGVzLmZpbHRlcigoYSkgPT4gYS5uYW1lWzBdID09PSAnQCcpLm1hcCgoYSkgPT4gdGhpcy5hcmcoYSkpO1xuXG4gICAgbGV0IG1vZGlmaWVycyA9IGVsZW1lbnQubW9kaWZpZXJzLm1hcCgobSkgPT4gdGhpcy5tb2RpZmllcihtKSk7XG5cbiAgICAvLyB0aGUgZWxlbWVudCdzIGJsb2NrIHBhcmFtcyBhcmUgaW4gc2NvcGUgZm9yIHRoZSBjaGlsZHJlblxuICAgIGxldCBjaGlsZCA9IHRoaXMuY3R4LmNoaWxkKGVsZW1lbnQuYmxvY2tQYXJhbXMpO1xuICAgIGxldCBub3JtYWxpemVyID0gbmV3IFN0YXRlbWVudE5vcm1hbGl6ZXIoY2hpbGQpO1xuXG4gICAgbGV0IGNoaWxkTm9kZXMgPSBlbGVtZW50LmNoaWxkcmVuLm1hcCgocykgPT4gbm9ybWFsaXplci5ub3JtYWxpemUocykpO1xuXG4gICAgbGV0IGVsID0gdGhpcy5jdHguYnVpbGRlci5lbGVtZW50KHtcbiAgICAgIHNlbGZDbG9zaW5nLFxuICAgICAgYXR0cnMsXG4gICAgICBjb21wb25lbnRBcmdzOiBhcmdzLFxuICAgICAgbW9kaWZpZXJzLFxuICAgICAgY29tbWVudHM6IGNvbW1lbnRzLm1hcCgoYykgPT4gbmV3IFN0YXRlbWVudE5vcm1hbGl6ZXIodGhpcy5jdHgpLk11c3RhY2hlQ29tbWVudFN0YXRlbWVudChjKSksXG4gICAgfSk7XG5cbiAgICBsZXQgY2hpbGRyZW4gPSBuZXcgRWxlbWVudENoaWxkcmVuKGVsLCBsb2MsIGNoaWxkTm9kZXMsIHRoaXMuY3R4KTtcblxuICAgIGxldCBvZmZzZXRzID0gdGhpcy5jdHgubG9jKGVsZW1lbnQubG9jKTtcbiAgICBsZXQgdGFnT2Zmc2V0cyA9IG9mZnNldHMuc2xpY2VTdGFydENoYXJzKHsgY2hhcnM6IHRhZy5sZW5ndGgsIHNraXBTdGFydDogMSB9KTtcblxuICAgIGlmIChwYXRoID09PSAnRWxlbWVudEhlYWQnKSB7XG4gICAgICBpZiAodGFnWzBdID09PSAnOicpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuLmFzc2VydE5hbWVkQmxvY2soXG4gICAgICAgICAgdGFnT2Zmc2V0cy5zbGljZSh7IHNraXBTdGFydDogMSB9KS50b1NsaWNlKHRhZy5zbGljZSgxKSksXG4gICAgICAgICAgY2hpbGQudGFibGVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5hc3NlcnRFbGVtZW50KHRhZ09mZnNldHMudG9TbGljZSh0YWcpLCBlbGVtZW50LmJsb2NrUGFyYW1zLmxlbmd0aCA+IDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnNlbGZDbG9zaW5nKSB7XG4gICAgICByZXR1cm4gZWwuc2VsZkNsb3NpbmdDb21wb25lbnQocGF0aCwgbG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGJsb2NrcyA9IGNoaWxkcmVuLmFzc2VydENvbXBvbmVudCh0YWcsIGNoaWxkLnRhYmxlLCBlbGVtZW50LmJsb2NrUGFyYW1zLmxlbmd0aCA+IDApO1xuICAgICAgcmV0dXJuIGVsLmNvbXBvbmVudFdpdGhOYW1lZEJsb2NrcyhwYXRoLCBibG9ja3MsIGxvYyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBtb2RpZmllcihtOiBBU1R2MS5FbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnQpOiBBU1R2Mi5FbGVtZW50TW9kaWZpZXIge1xuICAgIGxldCByZXNvbHV0aW9uID0gdGhpcy5jdHgucmVzb2x1dGlvbkZvcihtLCBNb2RpZmllclN5bnRheENvbnRleHQpO1xuXG4gICAgaWYgKHJlc29sdXRpb24ucmVzb2x1dGlvbiA9PT0gJ2Vycm9yJykge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgYFlvdSBhdHRlbXB0ZWQgdG8gaW52b2tlIGEgcGF0aCAoXFxge3sjJHtyZXNvbHV0aW9uLnBhdGh9fX1cXGApIGFzIGEgbW9kaWZpZXIsIGJ1dCAke3Jlc29sdXRpb24uaGVhZH0gd2FzIG5vdCBpbiBzY29wZS4gVHJ5IGFkZGluZyBcXGB0aGlzXFxgIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHBhdGhgLFxuICAgICAgICBtLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgY2FsbFBhcnRzID0gdGhpcy5leHByLmNhbGxQYXJ0cyhtLCByZXNvbHV0aW9uLnJlc29sdXRpb24pO1xuICAgIHJldHVybiB0aGlzLmN0eC5idWlsZGVyLm1vZGlmaWVyKGNhbGxQYXJ0cywgdGhpcy5jdHgubG9jKG0ubG9jKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaGFuZGxlcyBhdHRyaWJ1dGUgdmFsdWVzIHRoYXQgYXJlIGN1cmxpZXMsIGFzIHdlbGwgYXMgY3VybGllcyBuZXN0ZWQgaW5zaWRlIG9mXG4gICAqIGludGVycG9sYXRpb25zOlxuICAgKlxuICAgKiBgYGBoYnNcbiAgICogPGEgaHJlZj17e3VybH19IC8+XG4gICAqIDxhIGhyZWY9XCJ7e3VybH19Lmh0bWxcIiAvPlxuICAgKiBgYGBcbiAgICovXG4gIHByaXZhdGUgbXVzdGFjaGVBdHRyKG11c3RhY2hlOiBBU1R2MS5NdXN0YWNoZVN0YXRlbWVudCk6IEFTVHYyLkV4cHJlc3Npb25Ob2RlIHtcbiAgICAvLyBOb3JtYWxpemUgdGhlIGNhbGwgcGFydHMgaW4gQXR0clZhbHVlU3ludGF4Q29udGV4dFxuICAgIGxldCBzZXhwID0gdGhpcy5jdHguYnVpbGRlci5zZXhwKFxuICAgICAgdGhpcy5leHByLmNhbGxQYXJ0cyhtdXN0YWNoZSwgQXR0clZhbHVlU3ludGF4Q29udGV4dChtdXN0YWNoZSkpLFxuICAgICAgdGhpcy5jdHgubG9jKG11c3RhY2hlLmxvYylcbiAgICApO1xuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBhcmFtcyBvciBoYXNoLCBqdXN0IHJldHVybiB0aGUgZnVuY3Rpb24gcGFydCBhcyBpdHMgb3duIGV4cHJlc3Npb25cbiAgICBpZiAoc2V4cC5hcmdzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHNleHAuY2FsbGVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2V4cDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogYXR0clBhcnQgaXMgdGhlIG5hcnJvd2VkIGRvd24gbGlzdCBvZiB2YWxpZCBhdHRyaWJ1dGUgdmFsdWVzIHRoYXQgYXJlIGFsc29cbiAgICogYWxsb3dlZCBhcyBhIGNvbmNhdCBwYXJ0ICh5b3UgY2FuJ3QgbmVzdCBjb25jYXRzKS5cbiAgICovXG4gIHByaXZhdGUgYXR0clBhcnQoXG4gICAgcGFydDogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQgfCBBU1R2MS5UZXh0Tm9kZVxuICApOiB7IGV4cHI6IEFTVHYyLkV4cHJlc3Npb25Ob2RlOyB0cnVzdGluZzogYm9vbGVhbiB9IHtcbiAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgY2FzZSAnTXVzdGFjaGVTdGF0ZW1lbnQnOlxuICAgICAgICByZXR1cm4geyBleHByOiB0aGlzLm11c3RhY2hlQXR0cihwYXJ0KSwgdHJ1c3Rpbmc6ICFwYXJ0LmVzY2FwZWQgfTtcbiAgICAgIGNhc2UgJ1RleHROb2RlJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleHByOiB0aGlzLmN0eC5idWlsZGVyLmxpdGVyYWwocGFydC5jaGFycywgdGhpcy5jdHgubG9jKHBhcnQubG9jKSksXG4gICAgICAgICAgdHJ1c3Rpbmc6IHRydWUsXG4gICAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhdHRyVmFsdWUoXG4gICAgcGFydDogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQgfCBBU1R2MS5UZXh0Tm9kZSB8IEFTVHYxLkNvbmNhdFN0YXRlbWVudFxuICApOiB7IGV4cHI6IEFTVHYyLkV4cHJlc3Npb25Ob2RlOyB0cnVzdGluZzogYm9vbGVhbiB9IHtcbiAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgY2FzZSAnQ29uY2F0U3RhdGVtZW50Jzoge1xuICAgICAgICBsZXQgcGFydHMgPSBwYXJ0LnBhcnRzLm1hcCgocCkgPT4gdGhpcy5hdHRyUGFydChwKS5leHByKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleHByOiB0aGlzLmN0eC5idWlsZGVyLmludGVycG9sYXRlKHBhcnRzLCB0aGlzLmN0eC5sb2MocGFydC5sb2MpKSxcbiAgICAgICAgICB0cnVzdGluZzogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyUGFydChwYXJ0KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGF0dHIobTogQVNUdjEuQXR0ck5vZGUpOiBBU1R2Mi5IdG1sT3JTcGxhdEF0dHIge1xuICAgIGFzc2VydChtLm5hbWVbMF0gIT09ICdAJywgJ0FuIGF0dHIgbmFtZSBtdXN0IG5vdCBzdGFydCB3aXRoIGBAYCcpO1xuXG4gICAgaWYgKG0ubmFtZSA9PT0gJy4uLmF0dHJpYnV0ZXMnKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdHguYnVpbGRlci5zcGxhdEF0dHIodGhpcy5jdHgudGFibGUuYWxsb2NhdGVCbG9jaygnYXR0cnMnKSwgdGhpcy5jdHgubG9jKG0ubG9jKSk7XG4gICAgfVxuXG4gICAgbGV0IG9mZnNldHMgPSB0aGlzLmN0eC5sb2MobS5sb2MpO1xuICAgIGxldCBuYW1lU2xpY2UgPSBvZmZzZXRzLnNsaWNlU3RhcnRDaGFycyh7IGNoYXJzOiBtLm5hbWUubGVuZ3RoIH0pLnRvU2xpY2UobS5uYW1lKTtcblxuICAgIGxldCB2YWx1ZSA9IHRoaXMuYXR0clZhbHVlKG0udmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmN0eC5idWlsZGVyLmF0dHIoXG4gICAgICB7IG5hbWU6IG5hbWVTbGljZSwgdmFsdWU6IHZhbHVlLmV4cHIsIHRydXN0aW5nOiB2YWx1ZS50cnVzdGluZyB9LFxuICAgICAgb2Zmc2V0c1xuICAgICk7XG4gIH1cblxuICBwcml2YXRlIG1heWJlRGVwcmVjYXRlZENhbGwoXG4gICAgYXJnOiBTb3VyY2VTbGljZSxcbiAgICBwYXJ0OiBBU1R2MS5NdXN0YWNoZVN0YXRlbWVudCB8IEFTVHYxLlRleHROb2RlIHwgQVNUdjEuQ29uY2F0U3RhdGVtZW50XG4gICk6IHsgZXhwcjogQVNUdjIuRGVwcmVjYXRlZENhbGxFeHByZXNzaW9uOyB0cnVzdGluZzogYm9vbGVhbiB9IHwgbnVsbCB7XG4gICAgaWYgKHRoaXMuY3R4LnN0cmljdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHBhcnQudHlwZSAhPT0gJ011c3RhY2hlU3RhdGVtZW50Jykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHsgcGF0aCB9ID0gcGFydDtcblxuICAgIGlmIChwYXRoLnR5cGUgIT09ICdQYXRoRXhwcmVzc2lvbicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChwYXRoLmhlYWQudHlwZSAhPT0gJ1ZhckhlYWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgeyBuYW1lIH0gPSBwYXRoLmhlYWQ7XG5cbiAgICBpZiAobmFtZSA9PT0gJ2hhcy1ibG9jaycgfHwgbmFtZSA9PT0gJ2hhcy1ibG9jay1wYXJhbXMnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jdHguaGFzQmluZGluZyhuYW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHBhdGgudGFpbC5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChwYXJ0LnBhcmFtcy5sZW5ndGggIT09IDAgfHwgcGFydC5oYXNoLnBhaXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGNvbnRleHQgPSBBU1R2Mi5Mb29zZU1vZGVSZXNvbHV0aW9uLmF0dHIoKTtcblxuICAgIGxldCBjYWxsZWUgPSB0aGlzLmN0eC5idWlsZGVyLmZyZWVWYXIoe1xuICAgICAgbmFtZSxcbiAgICAgIGNvbnRleHQsXG4gICAgICBzeW1ib2w6IHRoaXMuY3R4LnRhYmxlLmFsbG9jYXRlRnJlZShuYW1lLCBjb250ZXh0KSxcbiAgICAgIGxvYzogcGF0aC5sb2MsXG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXhwcjogdGhpcy5jdHguYnVpbGRlci5kZXByZWNhdGVkQ2FsbChhcmcsIGNhbGxlZSwgcGFydC5sb2MpLFxuICAgICAgdHJ1c3Rpbmc6IGZhbHNlLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGFyZyhhcmc6IEFTVHYxLkF0dHJOb2RlKTogQVNUdjIuQ29tcG9uZW50QXJnIHtcbiAgICBhc3NlcnQoYXJnLm5hbWVbMF0gPT09ICdAJywgJ0FuIGFyZyBuYW1lIG11c3Qgc3RhcnQgd2l0aCBgQGAnKTtcblxuICAgIGxldCBvZmZzZXRzID0gdGhpcy5jdHgubG9jKGFyZy5sb2MpO1xuICAgIGxldCBuYW1lU2xpY2UgPSBvZmZzZXRzLnNsaWNlU3RhcnRDaGFycyh7IGNoYXJzOiBhcmcubmFtZS5sZW5ndGggfSkudG9TbGljZShhcmcubmFtZSk7XG5cbiAgICBsZXQgdmFsdWUgPSB0aGlzLm1heWJlRGVwcmVjYXRlZENhbGwobmFtZVNsaWNlLCBhcmcudmFsdWUpIHx8IHRoaXMuYXR0clZhbHVlKGFyZy52YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuY3R4LmJ1aWxkZXIuYXJnKFxuICAgICAgeyBuYW1lOiBuYW1lU2xpY2UsIHZhbHVlOiB2YWx1ZS5leHByLCB0cnVzdGluZzogdmFsdWUudHJ1c3RpbmcgfSxcbiAgICAgIG9mZnNldHNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gY2xhc3NpZmllcyB0aGUgaGVhZCBvZiBhbiBBU1R2MS5FbGVtZW50IGludG8gYW4gQVNUdjIuUGF0aEhlYWQgKGlmIHRoZVxuICAgKiBlbGVtZW50IGlzIGEgY29tcG9uZW50KSBvciBgJ0VsZW1lbnRIZWFkJ2AgKGlmIHRoZSBlbGVtZW50IGlzIGEgc2ltcGxlIGVsZW1lbnQpLlxuICAgKlxuICAgKiBSdWxlczpcbiAgICpcbiAgICogMS4gSWYgdGhlIHZhcmlhYmxlIGlzIGFuIGBAYXJnYCwgcmV0dXJuIGFuIGBBdEhlYWRgXG4gICAqIDIuIElmIHRoZSB2YXJpYWJsZSBpcyBgdGhpc2AsIHJldHVybiBhIGBUaGlzSGVhZGBcbiAgICogMy4gSWYgdGhlIHZhcmlhYmxlIGlzIGluIHRoZSBjdXJyZW50IHNjb3BlOlxuICAgKiAgIGEuIElmIHRoZSBzY29wZSBpcyB0aGUgcm9vdCBzY29wZSwgdGhlbiByZXR1cm4gYSBGcmVlIGBMb2NhbFZhckhlYWRgXG4gICAqICAgYi4gRWxzZSwgcmV0dXJuIGEgc3RhbmRhcmQgYExvY2FsVmFySGVhZGBcbiAgICogNC4gSWYgdGhlIHRhZyBuYW1lIGlzIGEgcGF0aCBhbmQgdGhlIHZhcmlhYmxlIGlzIG5vdCBpbiB0aGUgY3VycmVudCBzY29wZSwgU3ludGF4IEVycm9yXG4gICAqIDUuIElmIHRoZSB2YXJpYWJsZSBpcyB1cHBlcmNhc2UgcmV0dXJuIGEgRnJlZVZhcihSZXNvbHZlQXNDb21wb25lbnRIZWFkKVxuICAgKiA2LiBPdGhlcndpc2UsIHJldHVybiBgJ0VsZW1lbnRIZWFkJ2BcbiAgICovXG4gIHByaXZhdGUgY2xhc3NpZnlUYWcoXG4gICAgdmFyaWFibGU6IHN0cmluZyxcbiAgICB0YWlsOiBzdHJpbmdbXSxcbiAgICBsb2M6IFNvdXJjZVNwYW5cbiAgKTogQVNUdjIuRXhwcmVzc2lvbk5vZGUgfCAnRWxlbWVudEhlYWQnIHtcbiAgICBsZXQgdXBwZXJjYXNlID0gaXNVcHBlckNhc2UodmFyaWFibGUpO1xuICAgIGxldCBpblNjb3BlID0gdmFyaWFibGVbMF0gPT09ICdAJyB8fCB2YXJpYWJsZSA9PT0gJ3RoaXMnIHx8IHRoaXMuY3R4Lmhhc0JpbmRpbmcodmFyaWFibGUpO1xuXG4gICAgaWYgKHRoaXMuY3R4LnN0cmljdCAmJiAhaW5TY29wZSkge1xuICAgICAgaWYgKHVwcGVyY2FzZSkge1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gaW52b2tlIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBpbiBzY29wZSBpbiBhIHN0cmljdCBtb2RlIHRlbXBsYXRlLCBcXGA8JHt2YXJpYWJsZX0+XFxgLiBJZiB5b3Ugd2FudGVkIHRvIGNyZWF0ZSBhbiBlbGVtZW50IHdpdGggdGhhdCBuYW1lLCBjb252ZXJ0IGl0IHRvIGxvd2VyY2FzZSAtIFxcYDwke3ZhcmlhYmxlLnRvTG93ZXJDYXNlKCl9PlxcYGAsXG4gICAgICAgICAgbG9jXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIEluIHN0cmljdCBtb2RlLCB2YWx1ZXMgYXJlIGFsd2F5cyBlbGVtZW50cyB1bmxlc3MgdGhleSBhcmUgaW4gc2NvcGVcbiAgICAgIHJldHVybiAnRWxlbWVudEhlYWQnO1xuICAgIH1cblxuICAgIC8vIFNpbmNlIHRoZSBwYXJzZXIgaGFuZGVkIHVzIHRoZSBIVE1MIGVsZW1lbnQgbmFtZSBhcyBhIHN0cmluZywgd2UgbmVlZFxuICAgIC8vIHRvIGNvbnZlcnQgaXQgaW50byBhbiBBU1R2MSBwYXRoIHNvIGl0IGNhbiBiZSBwcm9jZXNzZWQgdXNpbmcgdGhlXG4gICAgLy8gZXhwcmVzc2lvbiBub3JtYWxpemVyLlxuICAgIGxldCBpc0NvbXBvbmVudCA9IGluU2NvcGUgfHwgdXBwZXJjYXNlO1xuXG4gICAgbGV0IHZhcmlhYmxlTG9jID0gbG9jLnNsaWNlU3RhcnRDaGFycyh7IHNraXBTdGFydDogMSwgY2hhcnM6IHZhcmlhYmxlLmxlbmd0aCB9KTtcblxuICAgIGxldCB0YWlsTGVuZ3RoID0gdGFpbC5yZWR1Y2UoKGFjY3VtLCBwYXJ0KSA9PiBhY2N1bSArIDEgKyBwYXJ0Lmxlbmd0aCwgMCk7XG4gICAgbGV0IHBhdGhFbmQgPSB2YXJpYWJsZUxvYy5nZXRFbmQoKS5tb3ZlKHRhaWxMZW5ndGgpO1xuICAgIGxldCBwYXRoTG9jID0gdmFyaWFibGVMb2Mud2l0aEVuZChwYXRoRW5kKTtcblxuICAgIGlmIChpc0NvbXBvbmVudCkge1xuICAgICAgbGV0IHBhdGggPSBiLnBhdGgoe1xuICAgICAgICBoZWFkOiBiLmhlYWQodmFyaWFibGUsIHZhcmlhYmxlTG9jKSxcbiAgICAgICAgdGFpbCxcbiAgICAgICAgbG9jOiBwYXRoTG9jLFxuICAgICAgfSk7XG5cbiAgICAgIGxldCByZXNvbHV0aW9uID0gdGhpcy5jdHgucmVzb2x1dGlvbkZvcihwYXRoLCBDb21wb25lbnRTeW50YXhDb250ZXh0KTtcblxuICAgICAgaWYgKHJlc29sdXRpb24ucmVzb2x1dGlvbiA9PT0gJ2Vycm9yJykge1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBZb3UgYXR0ZW1wdGVkIHRvIGludm9rZSBhIHBhdGggKFxcYDwke3Jlc29sdXRpb24ucGF0aH0+XFxgKSBidXQgJHtyZXNvbHV0aW9uLmhlYWR9IHdhcyBub3QgaW4gc2NvcGVgLFxuICAgICAgICAgIGxvY1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25Ob3JtYWxpemVyKHRoaXMuY3R4KS5ub3JtYWxpemUocGF0aCwgcmVzb2x1dGlvbi5yZXNvbHV0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdGFnIG5hbWUgd2Fzbid0IGEgdmFsaWQgY29tcG9uZW50IGJ1dCBjb250YWluZWQgYSBgLmAsIGl0J3NcbiAgICAvLyBhIHN5bnRheCBlcnJvci5cbiAgICBpZiAodGFpbC5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgWW91IHVzZWQgJHt2YXJpYWJsZX0uJHt0YWlsLmpvaW4oJy4nKX0gYXMgYSB0YWcgbmFtZSwgYnV0ICR7dmFyaWFibGV9IGlzIG5vdCBpbiBzY29wZWAsXG4gICAgICAgIGxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJ0VsZW1lbnRIZWFkJztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGV4cHIoKTogRXhwcmVzc2lvbk5vcm1hbGl6ZXIge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbk5vcm1hbGl6ZXIodGhpcy5jdHgpO1xuICB9XG59XG5cbmNsYXNzIENoaWxkcmVuIHtcbiAgcmVhZG9ubHkgbmFtZWRCbG9ja3M6IEFTVHYyLk5hbWVkQmxvY2tbXTtcbiAgcmVhZG9ubHkgaGFzU2VtYW50aWNDb250ZW50OiBib29sZWFuO1xuICByZWFkb25seSBub25CbG9ja0NoaWxkcmVuOiBBU1R2Mi5Db250ZW50Tm9kZVtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGxvYzogU291cmNlU3BhbixcbiAgICByZWFkb25seSBjaGlsZHJlbjogKEFTVHYyLkNvbnRlbnROb2RlIHwgQVNUdjIuTmFtZWRCbG9jaylbXSxcbiAgICByZWFkb25seSBibG9jazogQmxvY2tDb250ZXh0XG4gICkge1xuICAgIHRoaXMubmFtZWRCbG9ja3MgPSBjaGlsZHJlbi5maWx0ZXIoKGMpOiBjIGlzIEFTVHYyLk5hbWVkQmxvY2sgPT4gYyBpbnN0YW5jZW9mIEFTVHYyLk5hbWVkQmxvY2spO1xuICAgIHRoaXMuaGFzU2VtYW50aWNDb250ZW50ID0gQm9vbGVhbihcbiAgICAgIGNoaWxkcmVuLmZpbHRlcigoYyk6IGMgaXMgQVNUdjIuQ29udGVudE5vZGUgPT4ge1xuICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIEFTVHYyLk5hbWVkQmxvY2spIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdHbGltbWVyQ29tbWVudCc6XG4gICAgICAgICAgY2FzZSAnSHRtbENvbW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNhc2UgJ0h0bWxUZXh0JzpcbiAgICAgICAgICAgIHJldHVybiAhL15cXHMqJC8uZXhlYyhjLmNoYXJzKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pLmxlbmd0aFxuICAgICk7XG4gICAgdGhpcy5ub25CbG9ja0NoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKFxuICAgICAgKGMpOiBjIGlzIEFTVHYyLkNvbnRlbnROb2RlID0+ICEoYyBpbnN0YW5jZW9mIEFTVHYyLk5hbWVkQmxvY2spXG4gICAgKTtcbiAgfVxufVxuXG5jbGFzcyBUZW1wbGF0ZUNoaWxkcmVuIGV4dGVuZHMgQ2hpbGRyZW4ge1xuICBhc3NlcnRUZW1wbGF0ZSh0YWJsZTogUHJvZ3JhbVN5bWJvbFRhYmxlKTogQVNUdjIuVGVtcGxhdGUge1xuICAgIGlmIChpc1ByZXNlbnQodGhpcy5uYW1lZEJsb2NrcykpIHtcbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgbmFtZWQgYmxvY2sgYXQgdGhlIHRvcC1sZXZlbCBvZiBhIHRlbXBsYXRlYCwgdGhpcy5sb2MpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJsb2NrLmJ1aWxkZXIudGVtcGxhdGUodGFibGUsIHRoaXMubm9uQmxvY2tDaGlsZHJlbiwgdGhpcy5ibG9jay5sb2ModGhpcy5sb2MpKTtcbiAgfVxufVxuXG5jbGFzcyBCbG9ja0NoaWxkcmVuIGV4dGVuZHMgQ2hpbGRyZW4ge1xuICBhc3NlcnRCbG9jayh0YWJsZTogQmxvY2tTeW1ib2xUYWJsZSk6IEFTVHYyLkJsb2NrIHtcbiAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZWRCbG9ja3MpKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKGBVbmV4cGVjdGVkIG5hbWVkIGJsb2NrIG5lc3RlZCBpbiBhIG5vcm1hbCBibG9ja2AsIHRoaXMubG9jKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLmJsb2NrKHRhYmxlLCB0aGlzLm5vbkJsb2NrQ2hpbGRyZW4sIHRoaXMubG9jKTtcbiAgfVxufVxuXG5jbGFzcyBFbGVtZW50Q2hpbGRyZW4gZXh0ZW5kcyBDaGlsZHJlbiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWw6IEJ1aWxkRWxlbWVudCxcbiAgICBsb2M6IFNvdXJjZVNwYW4sXG4gICAgY2hpbGRyZW46IChBU1R2Mi5Db250ZW50Tm9kZSB8IEFTVHYyLk5hbWVkQmxvY2spW10sXG4gICAgYmxvY2s6IEJsb2NrQ29udGV4dFxuICApIHtcbiAgICBzdXBlcihsb2MsIGNoaWxkcmVuLCBibG9jayk7XG4gIH1cblxuICBhc3NlcnROYW1lZEJsb2NrKG5hbWU6IFNvdXJjZVNsaWNlLCB0YWJsZTogQmxvY2tTeW1ib2xUYWJsZSk6IEFTVHYyLk5hbWVkQmxvY2sge1xuICAgIGlmICh0aGlzLmVsLmJhc2Uuc2VsZkNsb3NpbmcpIHtcbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgIGA8OiR7bmFtZS5jaGFyc30vPiBpcyBub3QgYSB2YWxpZCBuYW1lZCBibG9jazogbmFtZWQgYmxvY2tzIGNhbm5vdCBiZSBzZWxmLWNsb3NpbmdgLFxuICAgICAgICB0aGlzLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZWRCbG9ja3MpKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZCBuYW1lZCBibG9jayBpbnNpZGUgPDoke25hbWUuY2hhcnN9PiBuYW1lZCBibG9jazogbmFtZWQgYmxvY2tzIGNhbm5vdCBjb250YWluIG5lc3RlZCBuYW1lZCBibG9ja3NgLFxuICAgICAgICB0aGlzLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzTG93ZXJDYXNlKG5hbWUuY2hhcnMpKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgPDoke25hbWUuY2hhcnN9PiBpcyBub3QgYSB2YWxpZCBuYW1lZCBibG9jaywgYW5kIG5hbWVkIGJsb2NrcyBtdXN0IGJlZ2luIHdpdGggYSBsb3dlcmNhc2UgbGV0dGVyYCxcbiAgICAgICAgdGhpcy5sb2NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdGhpcy5lbC5iYXNlLmF0dHJzLmxlbmd0aCA+IDAgfHxcbiAgICAgIHRoaXMuZWwuYmFzZS5jb21wb25lbnRBcmdzLmxlbmd0aCA+IDAgfHxcbiAgICAgIHRoaXMuZWwuYmFzZS5tb2RpZmllcnMubGVuZ3RoID4gMFxuICAgICkge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgYG5hbWVkIGJsb2NrIDw6JHtuYW1lLmNoYXJzfT4gY2Fubm90IGhhdmUgYXR0cmlidXRlcywgYXJndW1lbnRzLCBvciBtb2RpZmllcnNgLFxuICAgICAgICB0aGlzLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgb2Zmc2V0cyA9IFNwYW5MaXN0LnJhbmdlKHRoaXMubm9uQmxvY2tDaGlsZHJlbiwgdGhpcy5sb2MpO1xuXG4gICAgcmV0dXJuIHRoaXMuYmxvY2suYnVpbGRlci5uYW1lZEJsb2NrKFxuICAgICAgbmFtZSxcbiAgICAgIHRoaXMuYmxvY2suYnVpbGRlci5ibG9jayh0YWJsZSwgdGhpcy5ub25CbG9ja0NoaWxkcmVuLCBvZmZzZXRzKSxcbiAgICAgIHRoaXMubG9jXG4gICAgKTtcbiAgfVxuXG4gIGFzc2VydEVsZW1lbnQobmFtZTogU291cmNlU2xpY2UsIGhhc0Jsb2NrUGFyYW1zOiBib29sZWFuKTogQVNUdjIuU2ltcGxlRWxlbWVudCB7XG4gICAgaWYgKGhhc0Jsb2NrUGFyYW1zKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZCBibG9jayBwYXJhbXMgaW4gPCR7bmFtZX0+OiBzaW1wbGUgZWxlbWVudHMgY2Fubm90IGhhdmUgYmxvY2sgcGFyYW1zYCxcbiAgICAgICAgdGhpcy5sb2NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzUHJlc2VudCh0aGlzLm5hbWVkQmxvY2tzKSkge1xuICAgICAgbGV0IG5hbWVzID0gdGhpcy5uYW1lZEJsb2Nrcy5tYXAoKGIpID0+IGIubmFtZSk7XG5cbiAgICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgVW5leHBlY3RlZCBuYW1lZCBibG9jayA8OmZvbz4gaW5zaWRlIDwke25hbWUuY2hhcnN9PiBIVE1MIGVsZW1lbnRgLFxuICAgICAgICAgIHRoaXMubG9jXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcHJpbnRlZE5hbWVzID0gbmFtZXMubWFwKChuKSA9PiBgPDoke24uY2hhcnN9PmApLmpvaW4oJywgJyk7XG4gICAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgYFVuZXhwZWN0ZWQgbmFtZWQgYmxvY2tzIGluc2lkZSA8JHtuYW1lLmNoYXJzfT4gSFRNTCBlbGVtZW50ICgke3ByaW50ZWROYW1lc30pYCxcbiAgICAgICAgICB0aGlzLmxvY1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVsLnNpbXBsZShuYW1lLCB0aGlzLm5vbkJsb2NrQ2hpbGRyZW4sIHRoaXMubG9jKTtcbiAgfVxuXG4gIGFzc2VydENvbXBvbmVudChcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgdGFibGU6IEJsb2NrU3ltYm9sVGFibGUsXG4gICAgaGFzQmxvY2tQYXJhbXM6IGJvb2xlYW5cbiAgKTogUHJlc2VudEFycmF5PEFTVHYyLk5hbWVkQmxvY2s+IHtcbiAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZWRCbG9ja3MpICYmIHRoaXMuaGFzU2VtYW50aWNDb250ZW50KSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZCBjb250ZW50IGluc2lkZSA8JHtuYW1lfT4gY29tcG9uZW50IGludm9jYXRpb246IHdoZW4gdXNpbmcgbmFtZWQgYmxvY2tzLCB0aGUgdGFnIGNhbm5vdCBjb250YWluIG90aGVyIGNvbnRlbnRgLFxuICAgICAgICB0aGlzLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZWRCbG9ja3MpKSB7XG4gICAgICBpZiAoaGFzQmxvY2tQYXJhbXMpIHtcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgVW5leHBlY3RlZCBibG9jayBwYXJhbXMgbGlzdCBvbiA8JHtuYW1lfT4gY29tcG9uZW50IGludm9jYXRpb246IHdoZW4gcGFzc2luZyBuYW1lZCBibG9ja3MsIHRoZSBpbnZvY2F0aW9uIHRhZyBjYW5ub3QgdGFrZSBibG9jayBwYXJhbXNgLFxuICAgICAgICAgIHRoaXMubG9jXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGxldCBzZWVuTmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgICAgZm9yIChsZXQgYmxvY2sgb2YgdGhpcy5uYW1lZEJsb2Nrcykge1xuICAgICAgICBsZXQgbmFtZSA9IGJsb2NrLm5hbWUuY2hhcnM7XG5cbiAgICAgICAgaWYgKHNlZW5OYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgICAgYENvbXBvbmVudCBoYWQgdHdvIG5hbWVkIGJsb2NrcyB3aXRoIHRoZSBzYW1lIG5hbWUsIFxcYDw6JHtuYW1lfT5cXGAuIE9ubHkgb25lIGJsb2NrIHdpdGggYSBnaXZlbiBuYW1lIG1heSBiZSBwYXNzZWRgLFxuICAgICAgICAgICAgdGhpcy5sb2NcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIChuYW1lID09PSAnaW52ZXJzZScgJiYgc2Vlbk5hbWVzLmhhcygnZWxzZScpKSB8fFxuICAgICAgICAgIChuYW1lID09PSAnZWxzZScgJiYgc2Vlbk5hbWVzLmhhcygnaW52ZXJzZScpKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgICAgYENvbXBvbmVudCBoYXMgYm90aCA8OmVsc2U+IGFuZCA8OmludmVyc2U+IGJsb2NrLiA8OmludmVyc2U+IGlzIGFuIGFsaWFzIGZvciA8OmVsc2U+YCxcbiAgICAgICAgICAgIHRoaXMubG9jXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlZW5OYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm5hbWVkQmxvY2tzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB0aGlzLmJsb2NrLmJ1aWxkZXIubmFtZWRCbG9jayhcbiAgICAgICAgICBTb3VyY2VTbGljZS5zeW50aGV0aWMoJ2RlZmF1bHQnKSxcbiAgICAgICAgICB0aGlzLmJsb2NrLmJ1aWxkZXIuYmxvY2sodGFibGUsIHRoaXMubm9uQmxvY2tDaGlsZHJlbiwgdGhpcy5sb2MpLFxuICAgICAgICAgIHRoaXMubG9jXG4gICAgICAgICksXG4gICAgICBdO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFBhdGgobm9kZTogQVNUdjEuUGF0aEV4cHJlc3Npb24gfCBBU1R2MS5DYWxsTm9kZSk6IHN0cmluZyB7XG4gIGlmIChub2RlLnR5cGUgIT09ICdQYXRoRXhwcmVzc2lvbicgJiYgbm9kZS5wYXRoLnR5cGUgPT09ICdQYXRoRXhwcmVzc2lvbicpIHtcbiAgICByZXR1cm4gcHJpbnRQYXRoKG5vZGUucGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBQcmludGVyKHsgZW50aXR5RW5jb2Rpbmc6ICdyYXcnIH0pLnByaW50KG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50SGVhZChub2RlOiBBU1R2MS5QYXRoRXhwcmVzc2lvbiB8IEFTVHYxLkNhbGxOb2RlKTogc3RyaW5nIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ1BhdGhFeHByZXNzaW9uJykge1xuICAgIHN3aXRjaCAobm9kZS5oZWFkLnR5cGUpIHtcbiAgICAgIGNhc2UgJ0F0SGVhZCc6XG4gICAgICBjYXNlICdWYXJIZWFkJzpcbiAgICAgICAgcmV0dXJuIG5vZGUuaGVhZC5uYW1lO1xuICAgICAgY2FzZSAnVGhpc0hlYWQnOlxuICAgICAgICByZXR1cm4gJ3RoaXMnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnBhdGgudHlwZSA9PT0gJ1BhdGhFeHByZXNzaW9uJykge1xuICAgIHJldHVybiBwcmludEhlYWQobm9kZS5wYXRoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFByaW50ZXIoeyBlbnRpdHlFbmNvZGluZzogJ3JhdycgfSkucHJpbnQobm9kZSk7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=